--------------------------------------------------------------------------------
Profile data file 'callgrind.out.156382' (creator: callgrind-3.19.0.GIT)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 5380619
Trigger: Program termination
Profiled target:  ./minimap2 -ax map-ont -t 1 test/MT-human.fa test/MT-orang.fa (PID 156382, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                  
--------------------------------------------------------------------------------
62,735,565 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                   file:function
--------------------------------------------------------------------------------
31,885,949 (50.83%)  /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/emmintrin.h:ksw_extd2_sse41
 8,436,723 (13.45%)  ksw2_extd2_sse.c:ksw_extd2_sse41 [/home/kisliy/minimap2_v2.18/minimap2]
 4,436,579 ( 7.07%)  sketch.c:mm_sketch [/home/kisliy/minimap2_v2.18/minimap2]
 3,911,841 ( 6.24%)  /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/smmintrin.h:ksw_extd2_sse41
 2,551,778 ( 4.07%)  ???:_int_malloc [/usr/lib64/libc-2.17.so]
 1,245,799 ( 1.99%)  ???:_int_free [/usr/lib64/libc-2.17.so]
 1,001,711 ( 1.60%)  index.c:worker_post [/home/kisliy/minimap2_v2.18/minimap2]
   895,011 ( 1.43%)  ksw2.h:ksw_extd2_sse41
   875,295 ( 1.40%)  chain.c:mm_chain_dp [/home/kisliy/minimap2_v2.18/minimap2]
   491,755 ( 0.78%)  ???:free [/usr/lib64/libc-2.17.so]
   477,708 ( 0.76%)  ???:malloc [/usr/lib64/libc-2.17.so]
   465,284 ( 0.74%)  index.c:mm_idx_cal_max_occ [/home/kisliy/minimap2_v2.18/minimap2]
   455,829 ( 0.73%)  ???:calloc [/usr/lib64/libc-2.17.so]
   417,930 ( 0.67%)  index.c:mm_idx_getseq [/home/kisliy/minimap2_v2.18/minimap2]
   399,830 ( 0.64%)  align.c:mm_update_extra [/home/kisliy/minimap2_v2.18/minimap2]
   391,535 ( 0.62%)  align.c:mm_align1 [/home/kisliy/minimap2_v2.18/minimap2]
   378,114 ( 0.60%)  index.c:mm_idx_destroy [/home/kisliy/minimap2_v2.18/minimap2]
   368,884 ( 0.59%)  index.c:mm_idx_stat [/home/kisliy/minimap2_v2.18/minimap2]
   364,068 ( 0.58%)  bseq.c:mm_bseq_read3 [/home/kisliy/minimap2_v2.18/minimap2]
   297,108 ( 0.47%)  align.c:mm_align_skeleton [/home/kisliy/minimap2_v2.18/minimap2]
   259,396 ( 0.41%)  ???:realloc [/usr/lib64/libc-2.17.so]
   245,964 ( 0.39%)  bseq.c:ks_getuntil2 [/home/kisliy/minimap2_v2.18/minimap2]
   236,019 ( 0.38%)  map.c:collect_matches.isra.1 [/home/kisliy/minimap2_v2.18/minimap2]
   232,341 ( 0.37%)  index.c:worker_pipeline [/home/kisliy/minimap2_v2.18/minimap2]
   162,176 ( 0.26%)  kalloc.c:krealloc [/home/kisliy/minimap2_v2.18/minimap2]
   154,135 ( 0.25%)  kalloc.c:kfree [/home/kisliy/minimap2_v2.18/minimap2]
   133,240 ( 0.21%)  ???:do_lookup_x [/usr/lib64/ld-2.17.so]
   129,302 ( 0.21%)  ???:malloc_consolidate [/usr/lib64/libc-2.17.so]
   114,745 ( 0.18%)  kthread.c:kt_for [/home/kisliy/minimap2_v2.18/minimap2]
   109,655 ( 0.17%)  misc.c:rs_sort_128x'2 [/home/kisliy/minimap2_v2.18/minimap2]
    99,144 ( 0.16%)  index.c:mm_idx_get [/home/kisliy/minimap2_v2.18/minimap2]
    93,578 ( 0.15%)  index.c:mm_idx_add.isra.0 [/home/kisliy/minimap2_v2.18/minimap2]
    87,191 ( 0.14%)  ???:__GI_memset [/usr/lib64/libc-2.17.so]
    70,851 ( 0.11%)  esterr.c:mm_est_err [/home/kisliy/minimap2_v2.18/minimap2]
    61,567 ( 0.10%)  ???:_dl_lookup_symbol_x [/usr/lib64/ld-2.17.so]
    56,549 ( 0.09%)  ???:_dl_addr [/usr/lib64/libc-2.17.so]
    51,300 ( 0.08%)  ???:strcmp'2 [/usr/lib64/ld-2.17.so]
    48,196 ( 0.08%)  kalloc.c:kmalloc [/home/kisliy/minimap2_v2.18/minimap2]
    46,798 ( 0.07%)  misc.c:ks_ksmall_uint32_t [/home/kisliy/minimap2_v2.18/minimap2]

--------------------------------------------------------------------------------
-- Auto-annotated source: ksw2_extd2_sse.c
--------------------------------------------------------------------------------
Ir                 

-- line 29 ----------------------------------------
        .           #else
        .           void ksw_extd2_sse2(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,
        .           				   int8_t q, int8_t e, int8_t q2, int8_t e2, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez)
        .           #endif
        .           #else
        .           void ksw_extd2_sse(void *km, int qlen, const uint8_t *query, int tlen, const uint8_t *target, int8_t m, const int8_t *mat,
        .           				   int8_t q, int8_t e, int8_t q2, int8_t e2, int w, int zdrop, int end_bonus, int flag, ksw_extz_t *ez)
        .           #endif // ~KSW_CPU_DISPATCH
    1,232 ( 0.00%)  {
        .           #define __dp_code_block1 \
        .           	z = _mm_load_si128(&s[t]); \
        .           	xt1 = _mm_load_si128(&x[t]);                     /* xt1 <- x[r-1][t..t+15] */ \
        .           	tmp = _mm_srli_si128(xt1, 15);                   /* tmp <- x[r-1][t+15] */ \
        .           	xt1 = _mm_or_si128(_mm_slli_si128(xt1, 1), x1_); /* xt1 <- x[r-1][t-1..t+14] */ \
        .           	x1_ = tmp; \
        .           	vt1 = _mm_load_si128(&v[t]);                     /* vt1 <- v[r-1][t..t+15] */ \
        .           	tmp = _mm_srli_si128(vt1, 15);                   /* tmp <- v[r-1][t+15] */ \
-- line 45 ----------------------------------------
-- line 60 ----------------------------------------
        .           	_mm_store_si128(&v[t], _mm_sub_epi8(z, ut));     /* v[r][t..t+15] <- z - u[r-1][t..t+15] */ \
        .           	tmp = _mm_sub_epi8(z, q_); \
        .           	a = _mm_sub_epi8(a, tmp); \
        .           	b = _mm_sub_epi8(b, tmp); \
        .           	tmp = _mm_sub_epi8(z, q2_); \
        .           	a2= _mm_sub_epi8(a2, tmp); \
        .           	b2= _mm_sub_epi8(b2, tmp);
        .           
      784 ( 0.00%)  	int r, t, qe = q + e, n_col_, *off = 0, *off_end = 0, tlen_, qlen_, last_st, last_en, wl, wr, max_sc, min_sc, long_thres, long_diff;
      336 ( 0.00%)  	int with_cigar = !(flag&KSW_EZ_SCORE_ONLY), approx_max = !!(flag&KSW_EZ_APPROX_MAX);
      168 ( 0.00%)  	int32_t *H = 0, H0 = 0, last_H0_t = 0;
        .           	uint8_t *qr, *sf, *mem, *mem2 = 0;
        .           	__m128i q_, q2_, qe_, qe2_, zero_, sc_mch_, sc_mis_, m1_, sc_N_;
        .           	__m128i *u, *v, *x, *y, *x2, *y2, *s, *p = 0;
        .           
        .           	ksw_reset_extz(ez);
      392 ( 0.00%)  	if (m <= 1 || qlen <= 0 || tlen <= 0) return;
        .           
      448 ( 0.00%)  	if (q2 + e2 < q + e) t = q, q = q2, q2 = t, t = e, e = e2, e2 = t; // make sure q+e no larger than q2+e2
        .           
        .           	zero_   = _mm_set1_epi8(0);
        .           	q_      = _mm_set1_epi8(q);
        .           	q2_     = _mm_set1_epi8(q2);
      112 ( 0.00%)  	qe_     = _mm_set1_epi8(q + e);
      168 ( 0.00%)  	qe2_    = _mm_set1_epi8(q2 + e2);
      112 ( 0.00%)  	sc_mch_ = _mm_set1_epi8(mat[0]);
      112 ( 0.00%)  	sc_mis_ = _mm_set1_epi8(mat[1]);
      448 ( 0.00%)  	sc_N_   = mat[m*m-1] == 0? _mm_set1_epi8(-e2) : _mm_set1_epi8(mat[m*m-1]);
      224 ( 0.00%)  	m1_     = _mm_set1_epi8(m - 1); // wildcard
        .           
      168 ( 0.00%)  	if (w < 0) w = tlen > qlen? tlen : qlen;
        .           	wl = wr = w;
      224 ( 0.00%)  	tlen_ = (tlen + 15) / 16;
      168 ( 0.00%)  	n_col_ = qlen < tlen? qlen : tlen;
      392 ( 0.00%)  	n_col_ = ((n_col_ < w + 1? n_col_ : w + 1) + 15) / 16 + 1;
      168 ( 0.00%)  	qlen_ = (qlen + 15) / 16;
    2,856 ( 0.00%)  	for (t = 1, max_sc = mat[0], min_sc = mat[1]; t < m * m; ++t) {
    1,344 ( 0.00%)  		max_sc = max_sc > mat[t]? max_sc : mat[t];
    5,376 ( 0.01%)  		min_sc = min_sc < mat[t]? min_sc : mat[t];
        .           	}
      224 ( 0.00%)  	if (-min_sc > 2 * (q + e)) return; // otherwise, we won't see any mismatches
        .           
    1,008 ( 0.00%)  	long_thres = e != e2? (q2 - q) / (e - e2) - 1 : 0;
      224 ( 0.00%)  	if (q2 + e2 + long_thres * e2 > q + e + long_thres * e)
      224 ( 0.00%)  		++long_thres;
      392 ( 0.00%)  	long_diff = long_thres * (e - e2) - (q2 - q) - e2;
        .           
      392 ( 0.00%)  	mem = (uint8_t*)kcalloc(km, tlen_ * 8 + qlen_ + 1, 16);
   20,594 ( 0.03%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kcalloc (56x)
      168 ( 0.00%)  	u = (__m128i*)(((size_t)mem + 15) >> 4 << 4); // 16-byte aligned
      784 ( 0.00%)  	v = u + tlen_, x = v + tlen_, y = x + tlen_, x2 = y + tlen_, y2 = x2 + tlen_;
      616 ( 0.00%)  	s = y2 + tlen_, sf = (uint8_t*)(s + tlen_), qr = sf + tlen_ * 16;
      392 ( 0.00%)  	memset(u,  -q  - e,  tlen_ * 16);
    2,764 ( 0.00%)  => ???:__GI_memset (56x)
      280 ( 0.00%)  	memset(v,  -q  - e,  tlen_ * 16);
    2,624 ( 0.00%)  => ???:__GI_memset (56x)
      280 ( 0.00%)  	memset(x,  -q  - e,  tlen_ * 16);
    2,645 ( 0.00%)  => ???:__GI_memset (56x)
      280 ( 0.00%)  	memset(y,  -q  - e,  tlen_ * 16);
    2,722 ( 0.00%)  => ???:__GI_memset (56x)
      504 ( 0.00%)  	memset(x2, -q2 - e2, tlen_ * 16);
    2,764 ( 0.00%)  => ???:__GI_memset (56x)
      280 ( 0.00%)  	memset(y2, -q2 - e2, tlen_ * 16);
    2,624 ( 0.00%)  => ???:__GI_memset (56x)
      280 ( 0.00%)  	if (!approx_max) {
       14 ( 0.00%)  		H = (int32_t*)kmalloc(km, tlen_ * 16 * 4);
       68 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (2x)
      654 ( 0.00%)  		for (t = 0; t < tlen_ * 16; ++t) H[t] = KSW_NEG_INF;
        .           	}
      168 ( 0.00%)  	if (with_cigar) {
      952 ( 0.00%)  		mem2 = (uint8_t*)kmalloc(km, ((size_t)(qlen + tlen - 1) * n_col_ + 1) * 16);
    3,517 ( 0.01%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (56x)
      168 ( 0.00%)  		p = (__m128i*)(((size_t)mem2 + 15) >> 4 << 4);
      280 ( 0.00%)  		off = (int*)kmalloc(km, (qlen + tlen - 1) * sizeof(int) * 2);
    1,904 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (56x)
      392 ( 0.00%)  		off_end = off + qlen + tlen - 1;
        .           	}
        .           
   98,994 ( 0.16%)  	for (t = 0; t < qlen; ++t) qr[t] = query[qlen - 1 - t];
      280 ( 0.00%)  	memcpy(sf, target, tlen);
    4,879 ( 0.01%)  => ???:__memcpy_ssse3_back (56x)
        .           
   65,116 ( 0.10%)  	for (r = 0, last_st = last_en = -1; r < qlen + tlen - 1; ++r) {
   97,506 ( 0.16%)  		int st = 0, en = tlen - 1, st0, en0, st_, en_;
        .           		int8_t x1, x21, v1;
        .           		uint8_t *qrr = qr + (qlen - 1 - r);
        .           		int8_t *u8 = (int8_t*)u, *v8 = (int8_t*)v, *x8 = (int8_t*)x, *x28 = (int8_t*)x2;
        .           		__m128i x1_, x21_, v1_;
        .           		// find the boundaries
  340,527 ( 0.54%)  		if (st < r - qlen + 1) st = r - qlen + 1;
        .           		if (en > r) en = r;
  130,008 ( 0.21%)  		if (st < (r-wr+1)>>1) st = (r-wr+1)>>1; // take the ceil
   97,506 ( 0.16%)  		if (en > (r+wl)>>1) en = (r+wl)>>1; // take the floor
   65,004 ( 0.10%)  		if (st > en) {
        .           			ez->zdropped = 1;
        .           			break;
        .           		}
        .           		st0 = st, en0 = en;
  422,358 ( 0.67%)  		st = st / 16 * 16, en = (en + 16) / 16 * 16 - 1;
        .           		// set boundary conditions
   65,004 ( 0.10%)  		if (st > 0) {
   34,208 ( 0.05%)  			if (st - 1 >= last_st && st - 1 <= last_en) {
    8,730 ( 0.01%)  				x1 = x8[st - 1], x21 = x28[st - 1], v1 = v8[st - 1]; // (r-1,s-1) calculated in the last round
        .           			} else {
   70,970 ( 0.11%)  				x1 = -q - e, x21 = -q2 - e2;
   28,388 ( 0.05%)  				v1 = -q - e;
        .           			}
        .           		} else {
   86,690 ( 0.14%)  			x1 = -q - e, x21 = -q2 - e2;
  187,246 ( 0.30%)  			v1 = r == 0? -q - e : r < long_thres? -e : r == long_thres? long_diff : -e2;
        .           		}
   65,004 ( 0.10%)  		if (en >= r) {
  131,328 ( 0.21%)  			((int8_t*)y)[r] = -q - e, ((int8_t*)y2)[r] = -q2 - e2;
  177,004 ( 0.28%)  			u8[r] = r == 0? -q - e : r < long_thres? -e : r == long_thres? long_diff : -e2;
        .           		}
        .           		// loop fission: set scores first
  260,016 ( 0.41%)  		if (!(flag & KSW_EZ_GENERIC_SC)) {
  699,302 ( 1.11%)  			for (t = st0; t <= en0; t += 16) {
        .           				__m128i sq, st, tmp, mask;
        .           				sq = _mm_loadu_si128((__m128i*)&sf[t]);
        .           				st = _mm_loadu_si128((__m128i*)&qrr[t]);
        .           				mask = _mm_or_si128(_mm_cmpeq_epi8(sq, m1_), _mm_cmpeq_epi8(st, m1_));
        .           				tmp = _mm_cmpeq_epi8(sq, st);
        .           #ifdef __SSE4_1__
        .           				tmp = _mm_blendv_epi8(sc_mis_, sc_mch_, tmp);
        .           				tmp = _mm_blendv_epi8(tmp,     sc_N_,   mask);
-- line 174 ----------------------------------------
-- line 178 ----------------------------------------
        .           #endif
        .           				_mm_storeu_si128((__m128i*)((int8_t*)s + t), tmp);
        .           			}
        .           		} else {
        .           			for (t = st0; t <= en0; ++t)
        .           				((uint8_t*)s)[t] = mat[sf[t] * m + qrr[t]];
        .           		}
        .           		// core loop
   65,004 ( 0.10%)  		x1_  = _mm_cvtsi32_si128((uint8_t)x1);
   32,502 ( 0.05%)  		x21_ = _mm_cvtsi32_si128((uint8_t)x21);
   65,004 ( 0.10%)  		v1_  = _mm_cvtsi32_si128((uint8_t)v1);
  195,012 ( 0.31%)  		st_ = st / 16, en_ = en / 16;
  130,008 ( 0.21%)  		assert(en_ - st_ + 1 <= n_col_);
   97,506 ( 0.16%)  		if (!with_cigar) { // score only
        .           			for (t = st_; t <= en_; ++t) {
        .           				__m128i z, a, b, a2, b2, xt1, x2t1, vt1, ut, tmp;
1,069,233 ( 1.70%)  				__dp_code_block1;
        .           #ifdef __SSE4_1__
        .           				z = _mm_max_epi8(z, a);
        .           				z = _mm_max_epi8(z, b);
        .           				z = _mm_max_epi8(z, a2);
        .           				z = _mm_max_epi8(z, b2);
        .           				z = _mm_min_epi8(z, sc_mch_);
        .           				__dp_code_block2; // save u[] and v[]; update a, b, a2 and b2
        .           				_mm_store_si128(&x[t],  _mm_sub_epi8(_mm_max_epi8(a,  zero_), qe_));
-- line 202 ----------------------------------------
-- line 220 ----------------------------------------
        .           				tmp = _mm_cmpgt_epi8(b, zero_);
        .           				_mm_store_si128(&y[t],  _mm_sub_epi8(_mm_and_si128(tmp, b),  qe_));
        .           				tmp = _mm_cmpgt_epi8(a2, zero_);
        .           				_mm_store_si128(&x2[t], _mm_sub_epi8(_mm_and_si128(tmp, a2), qe2_));
        .           				tmp = _mm_cmpgt_epi8(b2, zero_);
        .           				_mm_store_si128(&y2[t], _mm_sub_epi8(_mm_and_si128(tmp, b2), qe2_));
        .           #endif
        .           			}
   65,004 ( 0.10%)  		} else if (!(flag&KSW_EZ_RIGHT)) { // gap left-alignment
  162,510 ( 0.26%)  			__m128i *pr = p + (size_t)r * n_col_ - st_;
  195,012 ( 0.31%)  			off[r] = st, off_end[r] = en;
1,034,358 ( 1.65%)  			for (t = st_; t <= en_; ++t) {
        .           				__m128i d, z, a, b, a2, b2, xt1, x2t1, vt1, ut, tmp;
  970,119 ( 1.55%)  				__dp_code_block1;
        .           #ifdef __SSE4_1__
        .           				d = _mm_and_si128(_mm_cmpgt_epi8(a, z), _mm_set1_epi8(1));       // d = a  > z? 1 : 0
        .           				z = _mm_max_epi8(z, a);
        .           				d = _mm_blendv_epi8(d, _mm_set1_epi8(2), _mm_cmpgt_epi8(b,  z)); // d = b  > z? 2 : d
        .           				z = _mm_max_epi8(z, b);
        .           				d = _mm_blendv_epi8(d, _mm_set1_epi8(3), _mm_cmpgt_epi8(a2, z)); // d = a2 > z? 3 : d
        .           				z = _mm_max_epi8(z, a2);
        .           				d = _mm_blendv_epi8(d, _mm_set1_epi8(4), _mm_cmpgt_epi8(b2, z)); // d = a2 > z? 3 : d
-- line 241 ----------------------------------------
-- line 270 ----------------------------------------
        .           				tmp = _mm_cmpgt_epi8(b2, zero_);
        .           				_mm_store_si128(&y2[t], _mm_sub_epi8(_mm_and_si128(tmp, b2), qe2_));
        .           				d = _mm_or_si128(d, _mm_and_si128(tmp, _mm_set1_epi8(0x40))); // d = b > 0? 1<<6 : 0
        .           				_mm_store_si128(&pr[t], d);
        .           			}
        .           		} else { // gap right-alignment
        .           			__m128i *pr = p + (size_t)r * n_col_ - st_;
        .           			off[r] = st, off_end[r] = en;
    3,685 ( 0.01%)  			for (t = st_; t <= en_; ++t) {
        .           				__m128i d, z, a, b, a2, b2, xt1, x2t1, vt1, ut, tmp;
    1,608 ( 0.00%)  				__dp_code_block1;
        .           #ifdef __SSE4_1__
        .           				d = _mm_andnot_si128(_mm_cmpgt_epi8(z, a), _mm_set1_epi8(1));    // d = z > a?  0 : 1
        .           				z = _mm_max_epi8(z, a);
        .           				d = _mm_blendv_epi8(_mm_set1_epi8(2), d, _mm_cmpgt_epi8(z, b));  // d = z > b?  d : 2
        .           				z = _mm_max_epi8(z, b);
        .           				d = _mm_blendv_epi8(_mm_set1_epi8(3), d, _mm_cmpgt_epi8(z, a2)); // d = z > a2? d : 3
        .           				z = _mm_max_epi8(z, a2);
        .           				d = _mm_blendv_epi8(_mm_set1_epi8(4), d, _mm_cmpgt_epi8(z, b2)); // d = z > b2? d : 4
-- line 288 ----------------------------------------
-- line 315 ----------------------------------------
        .           				_mm_store_si128(&x2[t], _mm_sub_epi8(_mm_andnot_si128(tmp, a2), qe2_));
        .           				d = _mm_or_si128(d, _mm_andnot_si128(tmp, _mm_set1_epi8(0x20))); // d = a > 0? 1<<5 : 0
        .           				tmp = _mm_cmpgt_epi8(zero_, b2);
        .           				_mm_store_si128(&y2[t], _mm_sub_epi8(_mm_andnot_si128(tmp, b2), qe2_));
        .           				d = _mm_or_si128(d, _mm_andnot_si128(tmp, _mm_set1_epi8(0x40))); // d = b > 0? 1<<6 : 0
        .           				_mm_store_si128(&pr[t], d);
        .           			}
        .           		}
   97,506 ( 0.16%)  		if (!approx_max) { // find the exact max with a 32-bit score array
        .           			int32_t max_H, max_t;
        .           			// compute H[], max_H and max_t
    1,408 ( 0.00%)  			if (r > 0) {
    4,914 ( 0.01%)  				int32_t HH[4], tt[4], en1 = st0 + (en0 - st0) / 4 * 4, i;
        .           				__m128i max_H_, max_t_;
    7,020 ( 0.01%)  				max_H = H[en0] = en0 > 0? H[en0-1] + u8[en0] : H[en0] + v8[en0]; // special casing the last element
        .           				max_t = en0;
        .           				max_H_ = _mm_set1_epi32(max_H);
        .           				max_t_ = _mm_set1_epi32(max_t);
   20,455 ( 0.03%)  				for (t = st0; t < en1; t += 4) { // this implements: H[t]+=v8[t]-qe; if(H[t]>max_H) max_H=H[t],max_t=t;
        .           					__m128i H1, tmp, t_;
        .           					H1 = _mm_loadu_si128((__m128i*)&H[t]);
   25,123 ( 0.04%)  					t_ = _mm_setr_epi32(v8[t], v8[t+1], v8[t+2], v8[t+3]);
        .           					H1 = _mm_add_epi32(H1, t_);
        .           					_mm_storeu_si128((__m128i*)&H[t], H1);
        .           					t_ = _mm_set1_epi32(t);
        .           					tmp = _mm_cmpgt_epi32(H1, max_H_);
        .           #ifdef __SSE4_1__
        .           					max_H_ = _mm_blendv_epi8(max_H_, H1, tmp);
        .           					max_t_ = _mm_blendv_epi8(max_t_, t_, tmp);
        .           #else
        .           					max_H_ = _mm_or_si128(_mm_and_si128(tmp, H1), _mm_andnot_si128(tmp, max_H_));
        .           					max_t_ = _mm_or_si128(_mm_and_si128(tmp, t_), _mm_andnot_si128(tmp, max_t_));
        .           #endif
        .           				}
        .           				_mm_storeu_si128((__m128i*)HH, max_H_);
        .           				_mm_storeu_si128((__m128i*)tt, max_t_);
    5,616 ( 0.01%)  				for (i = 0; i < 4; ++i)
   12,237 ( 0.02%)  					if (max_H < HH[i]) max_H = HH[i], max_t = tt[i] + i;
   11,649 ( 0.02%)  				for (; t < en0; ++t) { // for the rest of values that haven't been computed with SSE
    4,161 ( 0.01%)  					H[t] += (int32_t)v8[t];
    2,794 ( 0.00%)  					if (H[t] > max_H)
        .           						max_H = H[t], max_t = t;
        .           				}
       14 ( 0.00%)  			} else H[0] = v8[0] - qe, max_H = H[0], max_t = 0; // special casing r==0
        .           			// update ez
    4,417 ( 0.01%)  			if (en0 == tlen - 1 && H[en0] > ez->mte)
      310 ( 0.00%)  				ez->mte = H[en0], ez->mte_q = r - en;
    3,710 ( 0.01%)  			if (r - st0 == qlen - 1 && H[st0] > ez->mqe)
      189 ( 0.00%)  				ez->mqe = H[st0], ez->mqe_t = st0;
        .           			if (ksw_apply_zdrop(ez, 1, max_H, r, max_t, zdrop, e2)) break;
    2,820 ( 0.00%)  			if (r == qlen + tlen - 2 && en0 == tlen - 1)
      290 ( 0.00%)  				ez->score = H[tlen - 1];
        .           		} else { // find approximate max; Z-drop might be inaccurate, too.
   63,596 ( 0.10%)  			if (r > 0) {
  317,440 ( 0.51%)  				if (last_H0_t >= st0 && last_H0_t <= en0 && last_H0_t + 1 >= st0 && last_H0_t + 1 <= en0) {
   95,022 ( 0.15%)  					int32_t d0 = v8[last_H0_t];
   63,348 ( 0.10%)  					int32_t d1 = u8[last_H0_t + 1];
   79,166 ( 0.13%)  					if (d0 > d1) H0 += d0;
   47,568 ( 0.08%)  					else H0 += d1, ++last_H0_t;
        .           				} else if (last_H0_t >= st0 && last_H0_t <= en0) {
      350 ( 0.00%)  					H0 += v8[last_H0_t];
        .           				} else {
        .           					++last_H0_t, H0 += u8[last_H0_t];
        .           				}
      378 ( 0.00%)  			} else H0 = v8[0] - qe, last_H0_t = 0;
   63,596 ( 0.10%)  			if ((flag & KSW_EZ_APPROX_DROP) && ksw_apply_zdrop(ez, 1, H0, r, last_H0_t, zdrop, e2)) break;
  257,308 ( 0.41%)  			if (r == qlen + tlen - 2 && en0 == tlen - 1)
      216 ( 0.00%)  				ez->score = H0;
        .           		}
        .           		last_st = st, last_en = en;
        .           		//for (t = st0; t <= en0; ++t) printf("(%d,%d)\t(%d,%d,%d,%d)\t%d\n", r, t, ((int8_t*)u)[t], ((int8_t*)v)[t], ((int8_t*)x)[t], ((int8_t*)y)[t], H[t]); // for debugging
        .           	}
      168 ( 0.00%)  	kfree(km, mem);
    2,841 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (56x)
      176 ( 0.00%)  	if (!approx_max) kfree(km, H);
      148 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (2x)
      168 ( 0.00%)  	if (with_cigar) { // backtrack
      224 ( 0.00%)  		int rev_cigar = !!(flag & KSW_EZ_REV_CIGAR);
      280 ( 0.00%)  		if (!ez->zdropped && !(flag&KSW_EZ_EXTZ_ONLY)) {
      216 ( 0.00%)  			ksw_backtrack(km, 1, rev_cigar, 0, (uint8_t*)p, off, off_end, n_col_*16, tlen-1, qlen-1, &ez->m_cigar, &ez->n_cigar, &ez->cigar);
       14 ( 0.00%)  		} else if (!ez->zdropped && (flag&KSW_EZ_EXTZ_ONLY) && ez->mqe + end_bonus > (int)ez->max) {
        .           			ez->reach_end = 1;
        .           			ksw_backtrack(km, 1, rev_cigar, 0, (uint8_t*)p, off, off_end, n_col_*16, ez->mqe_t, qlen-1, &ez->m_cigar, &ez->n_cigar, &ez->cigar);
       14 ( 0.00%)  		} else if (ez->max_t >= 0 && ez->max_q >= 0) {
        4 ( 0.00%)  			ksw_backtrack(km, 1, rev_cigar, 0, (uint8_t*)p, off, off_end, n_col_*16, ez->max_t, ez->max_q, &ez->m_cigar, &ez->n_cigar, &ez->cigar);
        .           		}
      448 ( 0.00%)  		kfree(km, mem2); kfree(km, off);
    7,876 ( 0.01%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (112x)
        .           	}
      448 ( 0.00%)  }
        .           #endif // __SSE2__

--------------------------------------------------------------------------------
-- Auto-annotated source: ksw2.h
--------------------------------------------------------------------------------
Ir               

-- line 97 ----------------------------------------
      .           #define kmalloc(km, size) malloc((size))
      .           #define kcalloc(km, count, size) calloc((count), (size))
      .           #define krealloc(km, ptr, size) realloc((ptr), (size))
      .           #define kfree(km, ptr) free((ptr))
      .           #endif
      .           
      .           static inline uint32_t *ksw_push_cigar(void *km, int *n_cigar, int *m_cigar, uint32_t *cigar, uint32_t op, int len)
      .           {
128,876 ( 0.21%)  	if (*n_cigar == 0 || op != (cigar[(*n_cigar) - 1]&0xf)) {
    520 ( 0.00%)  		if (*n_cigar == *m_cigar) {
     19 ( 0.00%)  			*m_cigar = *m_cigar? (*m_cigar)<<1 : 4;
     25 ( 0.00%)  			cigar = (uint32_t*)krealloc(km, cigar, (*m_cigar) << 2);
    628 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:krealloc (5x)
      .           		}
    516 ( 0.00%)  		cigar[(*n_cigar)++] = len<<4 | op;
 47,511 ( 0.08%)  	} else cigar[(*n_cigar)-1] += len<<4;
      .           	return cigar;
      .           }
      .           
      .           // In the backtrack matrix, value p[] has the following structure:
      .           //   bit 0-2: which type gets the max - 0 for H, 1 for E, 2 for F, 3 for \tilde{E} and 4 for \tilde{F}
      .           //   bit 3/0x08: 1 if a continuation on the E state (bit 5/0x20 for a continuation on \tilde{E})
      .           //   bit 4/0x10: 1 if a continuation on the F state (bit 6/0x40 for a continuation on \tilde{F})
      .           static inline void ksw_backtrack(void *km, int is_rot, int is_rev, int min_intron_len, const uint8_t *p, const int *off, const int *off_end, int n_col, int i0, int j0,
      .           								 int *m_cigar_, int *n_cigar_, uint32_t **cigar_)
      .           { // p[] - lower 3 bits: which type gets the max; bit
    222 ( 0.00%)  	int n_cigar = 0, m_cigar = *m_cigar_, i = i0, j = j0, r, state = 0;
     56 ( 0.00%)  	uint32_t *cigar = *cigar_, tmp;
 96,610 ( 0.15%)  	while (i >= 0 && j >= 0) { // at the beginning of the loop, _state_ tells us which state to check
 64,380 ( 0.10%)  		int force_state = -1;
      .           		if (is_rot) {
 32,104 ( 0.05%)  			r = i + j;
 48,199 ( 0.08%)  			if (i < off[r]) force_state = 2;
 64,380 ( 0.10%)  			if (off_end && i > off_end[r]) force_state = 1;
161,286 ( 0.26%)  			tmp = force_state < 0? p[(size_t)r * n_col + i - off[r]] : 0;
      .           		} else {
      .           			if (j < off[i]) force_state = 2;
      .           			if (off_end && j > off_end[i]) force_state = 1;
      .           			tmp = force_state < 0? p[(size_t)i * n_col + j - off[i]] : 0;
      .           		}
 32,190 ( 0.05%)  		if (state == 0) state = tmp & 7; // if requesting the H state, find state one maximizes it.
 32,564 ( 0.05%)  		else if (!(tmp >> (state + 2) & 1)) state = 0; // if requesting other states, _state_ stays the same if it is a continuation; otherwise, set to H
      .           		if (state == 0) state = tmp & 7; // TODO: probably this line can be merged into the "else if" line right above; not 100% sure
 32,190 ( 0.05%)  		if (force_state >= 0) state = force_state;
127,568 ( 0.20%)  		if (state == 0) cigar = ksw_push_cigar(km, &n_cigar, &m_cigar, cigar, 0, 1), --i, --j; // match
    895 ( 0.00%)  		else if (state == 1 || (state == 3 && min_intron_len <= 0)) cigar = ksw_push_cigar(km, &n_cigar, &m_cigar, cigar, 2, 1), --i; // deletion
      .           		else if (state == 3 && min_intron_len > 0) cigar = ksw_push_cigar(km, &n_cigar, &m_cigar, cigar, 3, 1), --i; // intron
    405 ( 0.00%)  		else cigar = ksw_push_cigar(km, &n_cigar, &m_cigar, cigar, 1, 1), --j; // insertion
      .           	}
    168 ( 0.00%)  	if (i >= 0) cigar = ksw_push_cigar(km, &n_cigar, &m_cigar, cigar, min_intron_len > 0 && i >= min_intron_len? 3 : 2, i + 1); // first deletion
    166 ( 0.00%)  	if (j >= 0) cigar = ksw_push_cigar(km, &n_cigar, &m_cigar, cigar, 1, j + 1); // first insertion
    168 ( 0.00%)  	if (!is_rev)
    560 ( 0.00%)  		for (i = 0; i < n_cigar>>1; ++i) // reverse CIGAR
    588 ( 0.00%)  			tmp = cigar[i], cigar[i] = cigar[n_cigar-1-i], cigar[n_cigar-1-i] = tmp;
    278 ( 0.00%)  	*m_cigar_ = m_cigar, *n_cigar_ = n_cigar, *cigar_ = cigar;
      .           }
      .           
      .           static inline void ksw_reset_extz(ksw_extz_t *ez)
      .           {
    280 ( 0.00%)  	ez->max_q = ez->max_t = ez->mqe_t = ez->mte_q = -1;
    392 ( 0.00%)  	ez->max = 0, ez->score = ez->mqe = ez->mte = KSW_NEG_INF;
    168 ( 0.00%)  	ez->n_cigar = 0, ez->zdropped = 0, ez->reach_end = 0;
      .           }
      .           
      .           static inline int ksw_apply_zdrop(ksw_extz_t *ez, int is_rot, int32_t H, int a, int b, int zdrop, int8_t e)
      .           {
      .           	int r, t;
      .           	if (is_rot) r = a, t = b;
      .           	else r = a + b, t = a;
  4,224 ( 0.01%)  	if (H > (int32_t)ez->max) {
    500 ( 0.00%)  		ez->max = H, ez->max_t = t, ez->max_q = r - t;
  6,540 ( 0.01%)  	} else if (t >= ez->max_t && r - t >= ez->max_q) {
  1,308 ( 0.00%)  		int tl = t - ez->max_t, ql = (r - t) - ez->max_q, l;
  3,924 ( 0.01%)  		l = tl > ql? tl - ql : ql - tl;
  5,232 ( 0.01%)  		if (zdrop >= 0 && ez->max - H > zdrop + l * e) {
      .           			ez->zdropped = 1;
      .           			return 1;
      .           		}
      .           	}
      .           	return 0;
      .           }
      .           #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: map.c
--------------------------------------------------------------------------------
Ir              

-- line 11 ----------------------------------------
     .           #include "khash.h"
     .           
     .           struct mm_tbuf_s {
     .           	void *km;
     .           	int rep_len, frag_gap;
     .           };
     .           
     .           mm_tbuf_t *mm_tbuf_init(void)
     1 ( 0.00%)  {
     .           	mm_tbuf_t *b;
     5 ( 0.00%)  	b = (mm_tbuf_t*)calloc(1, sizeof(mm_tbuf_t));
   220 ( 0.00%)  => ???:calloc (1x)
     4 ( 0.00%)  	if (!(mm_dbg_flag & 1)) b->km = km_init();
   237 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:km_init (1x)
     .           	return b;
     3 ( 0.00%)  }
     .           
     .           void mm_tbuf_destroy(mm_tbuf_t *b)
     2 ( 0.00%)  {
     2 ( 0.00%)  	if (b == 0) return;
     2 ( 0.00%)  	km_destroy(b->km);
   169 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:km_destroy (1x)
     3 ( 0.00%)  	free(b);
    88 ( 0.00%)  => ???:free (1x)
     1 ( 0.00%)  }
     .           
     .           void *mm_tbuf_get_km(mm_tbuf_t *b)
     .           {
     .           	return b->km;
     .           }
     .           
     .           static int mm_dust_minier(void *km, int n, mm128_t *a, int l_seq, const char *seq, int sdust_thres)
     .           {
     .           	int n_dreg, j, k, u = 0;
     .           	const uint64_t *dreg;
     .           	sdust_buf_t *sdb;
     .           	if (sdust_thres <= 0) return n;
     .           	sdb = sdust_buf_init(km);
     1 ( 0.00%)  	dreg = sdust_core((const uint8_t*)seq, l_seq, sdust_thres, 64, &n_dreg, sdb);
     .           	for (j = k = 0; j < n; ++j) { // squeeze out minimizers that significantly overlap with LCRs
     .           		int32_t qpos = (uint32_t)a[j].y>>1, span = a[j].x&0xff;
     .           		int32_t s = qpos - (span - 1), e = s + span;
     .           		while (u < n_dreg && (int32_t)dreg[u] <= s) ++u;
     .           		if (u < n_dreg && (int32_t)(dreg[u]>>32) < e) {
     .           			int v, l = 0;
     .           			for (v = u; v < n_dreg && (int32_t)(dreg[v]>>32) < e; ++v) { // iterate over LCRs overlapping this minimizer
     .           				int ss = s > (int32_t)(dreg[v]>>32)? s : dreg[v]>>32;
-- line 53 ----------------------------------------
-- line 58 ----------------------------------------
     .           		} else a[k++] = a[j];
     .           	}
     .           	sdust_buf_destroy(sdb);
     .           	return k; // the new size
     .           }
     .           
     .           static void collect_minimizers(void *km, const mm_mapopt_t *opt, const mm_idx_t *mi, int n_segs, const int *qlens, const char **seqs, mm128_v *mv)
     .           {
     1 ( 0.00%)  	int i, n, sum = 0;
     .           	mv->n = 0;
     3 ( 0.00%)  	for (i = n = 0; i < n_segs; ++i) {
     .           		size_t j;
    15 ( 0.00%)  		mm_sketch(km, seqs[i], qlens[i], mi->w, mi->k, i, mi->flag&MM_I_HPC, mv);
2,223,206 ( 3.54%)  => /home/kisliy/minimap2_v2.18/sketch.c:mm_sketch (1x)
 6,225 ( 0.01%)  		for (j = n; j < mv->n; ++j)
 6,210 ( 0.01%)  			mv->a[j].y += sum << 1;
     4 ( 0.00%)  		if (opt->sdust_thres > 0) // mask low-complexity minimizers
     .           			mv->n = n + mm_dust_minier(km, mv->n - n, mv->a + n, qlens[i], seqs[i], opt->sdust_thres);
     5 ( 0.00%)  		sum += qlens[i], n = mv->n;
     .           	}
     .           }
     .           
     .           #include "ksort.h"
     .           #define heap_lt(a, b) ((a).x > (b).x)
     .           KSORT_INIT(heap, mm128_t, heap_lt)
     .           
     .           typedef struct {
     .           	uint32_t n;
     .           	uint32_t q_pos, q_span;
     .           	uint32_t seg_id:31, is_tandem:1;
     .           	const uint64_t *cr;
     .           } mm_match_t;
     .           
    13 ( 0.00%)  static mm_match_t *collect_matches(void *km, int *_n_m, int max_occ, const mm_idx_t *mi, const mm128_v *mv, int64_t *n_a, int *rep_len, int *n_mini_pos, uint64_t **mini_pos)
     .           {
     3 ( 0.00%)  	int rep_st = 0, rep_en = 0, n_m;
     .           	size_t i;
     .           	mm_match_t *m;
     2 ( 0.00%)  	*n_mini_pos = 0;
     5 ( 0.00%)  	*mini_pos = (uint64_t*)kmalloc(km, mv->n * sizeof(uint64_t));
    36 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
     6 ( 0.00%)  	m = (mm_match_t*)kmalloc(km, mv->n * sizeof(mm_match_t));
    34 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
12,432 ( 0.02%)  	for (i = 0, n_m = 0, *rep_len = 0, *n_a = 0; i < mv->n; ++i) {
     .           		const uint64_t *cr;
 9,315 ( 0.01%)  		mm128_t *p = &mv->a[i];
12,420 ( 0.02%)  		uint32_t q_pos = (uint32_t)p->y, q_span = p->x & 0xff;
     .           		int t;
18,630 ( 0.03%)  		cr = mm_idx_get(mi, p->x>>8, &t);
99,144 ( 0.16%)  => /home/kisliy/minimap2_v2.18/index.c:mm_idx_get (3,105x)
15,525 ( 0.02%)  		if (t >= max_occ) {
     .           			int en = (q_pos >> 1) + 1, st = en - q_span;
     .           			if (st > rep_en) {
     .           				*rep_len += rep_en - rep_st;
     .           				rep_st = st, rep_en = en;
     .           			} else rep_en = en;
     .           		} else {
15,525 ( 0.02%)  			mm_match_t *q = &m[n_m++];
31,050 ( 0.05%)  			q->q_pos = q_pos, q->q_span = q_span, q->cr = cr, q->n = t, q->seg_id = p->y >> 32;
 9,315 ( 0.01%)  			q->is_tandem = 0;
27,938 ( 0.04%)  			if (i > 0 && p->x>>8 == mv->a[i - 1].x>>8) q->is_tandem = 1;
40,357 ( 0.06%)  			if (i < mv->n - 1 && p->x>>8 == mv->a[i + 1].x>>8) q->is_tandem = 1;
 6,210 ( 0.01%)  			*n_a += q->n;
37,260 ( 0.06%)  			(*mini_pos)[(*n_mini_pos)++] = (uint64_t)q_span<<32 | q_pos>>1;
     .           		}
     .           	}
     2 ( 0.00%)  	*rep_len += rep_en - rep_st;
     2 ( 0.00%)  	*_n_m = n_m;
     .           	return m;
     9 ( 0.00%)  }
     .           
     .           static inline int skip_seed(int flag, uint64_t r, const mm_match_t *q, const char *qname, int qlen, const mm_idx_t *mi, int *is_self)
     .           {
     .           	*is_self = 0;
 2,076 ( 0.00%)  	if (qname && (flag & (MM_F_NO_DIAG|MM_F_NO_DUAL))) {
     .           		const mm_idx_seq_t *s = &mi->seq[r>>32];
     .           		int cmp;
     .           		cmp = strcmp(qname, s->name);
   346 ( 0.00%)  		if ((flag&MM_F_NO_DIAG) && cmp == 0 && (int)s->len == qlen) {
     .           			if ((uint32_t)r>>1 == (q->q_pos>>1)) return 1; // avoid the diagnonal anchors
     .           			if ((r&1) == (q->q_pos&1)) *is_self = 1; // this flag is used to avoid spurious extension on self chain
     .           		}
   346 ( 0.00%)  		if ((flag&MM_F_NO_DUAL) && cmp > 0) // all-vs-all mode: map once
     .           			return 1;
     .           	}
   692 ( 0.00%)  	if (flag & (MM_F_FOR_ONLY|MM_F_REV_ONLY)) {
     .           		if ((r&1) == (q->q_pos&1)) { // forward strand
     .           			if (flag & MM_F_REV_ONLY) return 1;
     .           		} else {
     .           			if (flag & MM_F_FOR_ONLY) return 1;
     .           		}
     .           	}
     .           	return 0;
     .           }
-- line 147 ----------------------------------------
-- line 207 ----------------------------------------
     .           	}
     .           	if (*n_a > n_for + n_rev) {
     .           		memmove(a + n_for, a + (*n_a) - n_rev, n_rev * sizeof(mm128_t));
     .           		*n_a = n_for + n_rev;
     .           	}
     .           	return a;
     .           }
     .           
    14 ( 0.00%)  static mm128_t *collect_seed_hits(void *km, const mm_mapopt_t *opt, int max_occ, const mm_idx_t *mi, const char *qname, const mm128_v *mv, int qlen, int64_t *n_a, int *rep_len,
     .           								  int *n_mini_pos, uint64_t **mini_pos)
     .           {
     .           	int i, n_m;
     .           	mm_match_t *m;
     .           	mm128_t *a;
    12 ( 0.00%)  	m = collect_matches(km, &n_m, max_occ, mi, mv, n_a, rep_len, n_mini_pos, mini_pos);
335,233 ( 0.53%)  => map.c:collect_matches.isra.1 (1x)
     5 ( 0.00%)  	a = (mm128_t*)kmalloc(km, *n_a * sizeof(mm128_t));
    34 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
15,533 ( 0.02%)  	for (i = 0, *n_a = 0; i < n_m; ++i) {
     .           		mm_match_t *q = &m[i];
 3,105 ( 0.00%)  		const uint64_t *r = q->cr;
     .           		uint32_t k;
13,804 ( 0.02%)  		for (k = 0; k < q->n; ++k) {
 1,038 ( 0.00%)  			int32_t is_self, rpos = (uint32_t)r[k] >> 1;
     .           			mm128_t *p;
   346 ( 0.00%)  			if (skip_seed(opt->flag, r[k], q, qname, qlen, mi, &is_self)) continue;
 1,730 ( 0.00%)  			p = &a[(*n_a)++];
 1,384 ( 0.00%)  			if ((r[k]&1) == (q->q_pos&1)) { // forward strand
 1,387 ( 0.00%)  				p->x = (r[k]&0xffffffff00000000ULL) | rpos;
 1,384 ( 0.00%)  				p->y = (uint64_t)q->q_span << 32 | q->q_pos >> 1;
     .           			} else { // reverse strand
     .           				p->x = 1ULL<<63 | (r[k]&0xffffffff00000000ULL) | rpos;
     4 ( 0.00%)  				p->y = (uint64_t)q->q_span << 32 | (qlen - ((q->q_pos>>1) + 1 - q->q_span) - 1);
     .           			}
 1,384 ( 0.00%)  			p->y |= (uint64_t)q->seg_id << MM_SEED_SEG_SHIFT;
   692 ( 0.00%)  			if (q->is_tandem) p->y |= MM_SEED_TANDEM;
 1,038 ( 0.00%)  			if (is_self) p->y |= MM_SEED_SELF;
     .           		}
     .           	}
     3 ( 0.00%)  	kfree(km, m);
    41 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (1x)
     5 ( 0.00%)  	radix_sort_128x(a, a + (*n_a));
136,627 ( 0.22%)  => /home/kisliy/minimap2_v2.18/misc.c:radix_sort_128x (1x)
     .           	return a;
     9 ( 0.00%)  }
     .           
     .           static void chain_post(const mm_mapopt_t *opt, int max_chain_gap_ref, const mm_idx_t *mi, void *km, int qlen, int n_segs, const int *qlens, int *n_regs, mm_reg1_t *regs, mm128_t *a)
     .           {
     4 ( 0.00%)  	if (!(opt->flag & MM_F_ALL_CHAINS)) { // don't choose primary mapping(s)
    14 ( 0.00%)  		mm_set_parent(km, opt->mask_level, opt->mask_len, *n_regs, regs, opt->a * 2 + opt->b, opt->flag&MM_F_HARD_MLEVEL, opt->alt_drop);
   242 ( 0.00%)  => /home/kisliy/minimap2_v2.18/hit.c:mm_set_parent (1x)
    15 ( 0.00%)  		if (n_segs <= 1) mm_select_sub(km, opt->pri_ratio, mi->k*2, opt->best_n, n_regs, regs);
    62 ( 0.00%)  => /home/kisliy/minimap2_v2.18/hit.c:mm_select_sub (1x)
     .           		else mm_select_sub_multi(km, opt->pri_ratio, 0.2f, 0.7f, max_chain_gap_ref, mi->k*2, opt->best_n, n_segs, qlens, n_regs, regs);
     3 ( 0.00%)  		if (!(opt->flag & (MM_F_SPLICE|MM_F_SR|MM_F_NO_LJOIN))) // long join not working well without primary chains
     8 ( 0.00%)  			mm_join_long(km, opt, qlen, n_regs, regs, a);
    24 ( 0.00%)  => /home/kisliy/minimap2_v2.18/hit.c:mm_join_long (1x)
     .           	}
     .           }
     .           
    10 ( 0.00%)  static mm_reg1_t *align_regs(const mm_mapopt_t *opt, const mm_idx_t *mi, void *km, int qlen, const char *seq, int *n_regs, mm_reg1_t *regs, mm128_t *a)
     .           {
     4 ( 0.00%)  	if (!(opt->flag & MM_F_CIGAR)) return regs;
     9 ( 0.00%)  	regs = mm_align_skeleton(km, opt, mi, qlen, seq, n_regs, regs, a); // this calls mm_filter_regs()
46,722,443 (74.48%)  => /home/kisliy/minimap2_v2.18/align.c:mm_align_skeleton (1x)
     3 ( 0.00%)  	if (!(opt->flag & MM_F_ALL_CHAINS)) { // don't choose primary mapping(s)
    11 ( 0.00%)  		mm_set_parent(km, opt->mask_level, opt->mask_len, *n_regs, regs, opt->a * 2 + opt->b, opt->flag&MM_F_HARD_MLEVEL, opt->alt_drop);
   244 ( 0.00%)  => /home/kisliy/minimap2_v2.18/hit.c:mm_set_parent (1x)
     8 ( 0.00%)  		mm_select_sub(km, opt->pri_ratio, mi->k*2, opt->best_n, n_regs, regs);
    62 ( 0.00%)  => /home/kisliy/minimap2_v2.18/hit.c:mm_select_sub (1x)
     3 ( 0.00%)  		mm_set_sam_pri(*n_regs, regs);
    23 ( 0.00%)  => /home/kisliy/minimap2_v2.18/hit.c:mm_set_sam_pri (1x)
     .           	}
     .           	return regs;
     8 ( 0.00%)  }
     .           
     .           void mm_map_frag(const mm_idx_t *mi, int n_segs, const int *qlens, const char **seqs, int *n_regs, mm_reg1_t **regs, mm_tbuf_t *b, const mm_mapopt_t *opt, const char *qname)
    14 ( 0.00%)  {
     .           	int i, j, rep_len, qlen_sum, n_regs0, n_mini_pos;
    11 ( 0.00%)  	int max_chain_gap_qry, max_chain_gap_ref, is_splice = !!(opt->flag & MM_F_SPLICE), is_sr = !!(opt->flag & MM_F_SR);
     .           	uint32_t hash;
     .           	int64_t n_a;
     .           	uint64_t *u, *mini_pos;
     .           	mm128_t *a;
     3 ( 0.00%)  	mm128_v mv = {0,0,0};
     .           	mm_reg1_t *regs0;
     .           	km_stat_t kmst;
     .           
    11 ( 0.00%)  	for (i = 0, qlen_sum = 0; i < n_segs; ++i)
     5 ( 0.00%)  		qlen_sum += qlens[i], n_regs[i] = 0, regs[i] = 0;
     .           
     6 ( 0.00%)  	if (qlen_sum == 0 || n_segs <= 0 || n_segs > MM_MAX_SEG) return;
     4 ( 0.00%)  	if (opt->max_qlen > 0 && qlen_sum > opt->max_qlen) return;
     .           
     2 ( 0.00%)  	hash  = qname? __ac_X31_hash_string(qname) : 0;
     4 ( 0.00%)  	hash ^= __ac_Wang_hash(qlen_sum) + __ac_Wang_hash(opt->seed);
     .           	hash  = __ac_Wang_hash(hash);
     .           
     9 ( 0.00%)  	collect_minimizers(b->km, opt, mi, n_segs, qlens, seqs, &mv);
    25 ( 0.00%)  	if (opt->flag & MM_F_HEAP_SORT) a = collect_seed_hits_heap(b->km, opt, opt->mid_occ, mi, qname, &mv, qlen_sum, &n_a, &rep_len, &n_mini_pos, &mini_pos);
     3 ( 0.00%)  	else a = collect_seed_hits(b->km, opt, opt->mid_occ, mi, qname, &mv, qlen_sum, &n_a, &rep_len, &n_mini_pos, &mini_pos);
518,272 ( 0.83%)  => map.c:collect_seed_hits.isra.3 (1x)
     .           
     3 ( 0.00%)  	if (mm_dbg_flag & MM_DBG_PRINT_SEED) {
     .           		fprintf(stderr, "RS\t%d\n", rep_len);
     .           		for (i = 0; i < n_a; ++i)
     .           			fprintf(stderr, "SD\t%s\t%d\t%c\t%d\t%d\t%d\n", mi->seq[a[i].x<<1>>33].name, (int32_t)a[i].x, "+-"[a[i].x>>63], (int32_t)a[i].y, (int32_t)(a[i].y>>32&0xff),
     .           					i == 0? 0 : ((int32_t)a[i].y - (int32_t)a[i-1].y) - ((int32_t)a[i].x - (int32_t)a[i-1].x));
     .           	}
     .           
     .           	// set max chaining gap on the query and the reference sequence
     4 ( 0.00%)  	if (is_sr)
     2 ( 0.00%)  		max_chain_gap_qry = qlen_sum > opt->max_gap? qlen_sum : opt->max_gap;
     3 ( 0.00%)  	else max_chain_gap_qry = opt->max_gap;
     5 ( 0.00%)  	if (opt->max_gap_ref > 0) {
     .           		max_chain_gap_ref = opt->max_gap_ref; // always honor mm_mapopt_t::max_gap_ref if set
     4 ( 0.00%)  	} else if (opt->max_frag_len > 0) {
     .           		max_chain_gap_ref = opt->max_frag_len - qlen_sum;
     .           		if (max_chain_gap_ref < opt->max_gap) max_chain_gap_ref = opt->max_gap;
     2 ( 0.00%)  	} else max_chain_gap_ref = opt->max_gap;
     .           
    25 ( 0.00%)  	a = mm_chain_dp(max_chain_gap_ref, max_chain_gap_qry, opt->bw, opt->max_chain_skip, opt->max_chain_iter, opt->min_cnt, opt->min_chain_score, opt->chain_gap_scale, is_splice, n_segs, n_a, a, &n_regs0, &u, b->km);
878,264 ( 1.40%)  => /home/kisliy/minimap2_v2.18/chain.c:mm_chain_dp (1x)
     .           
     5 ( 0.00%)  	if (opt->max_occ > opt->mid_occ && rep_len > 0) {
     .           		int rechain = 0;
     .           		if (n_regs0 > 0) { // test if the best chain has all the segments
     .           			int n_chained_segs = 1, max = 0, max_i = -1, max_off = -1, off = 0;
     .           			for (i = 0; i < n_regs0; ++i) { // find the best chain
     .           				if (max < (int)(u[i]>>32)) max = u[i]>>32, max_i = i, max_off = off;
     .           				off += (uint32_t)u[i];
     .           			}
     .           			for (i = 1; i < (int32_t)u[max_i]; ++i) // count the number of segments in the best chain
-- line 326 ----------------------------------------
-- line 330 ----------------------------------------
     .           				rechain = 1;
     .           		} else rechain = 1;
     .           		if (rechain) { // redo chaining with a higher max_occ threshold
     .           			kfree(b->km, a);
     .           			kfree(b->km, u);
     .           			kfree(b->km, mini_pos);
     .           			if (opt->flag & MM_F_HEAP_SORT) a = collect_seed_hits_heap(b->km, opt, opt->max_occ, mi, qname, &mv, qlen_sum, &n_a, &rep_len, &n_mini_pos, &mini_pos);
     .           			else a = collect_seed_hits(b->km, opt, opt->max_occ, mi, qname, &mv, qlen_sum, &n_a, &rep_len, &n_mini_pos, &mini_pos);
     2 ( 0.00%)  			a = mm_chain_dp(max_chain_gap_ref, max_chain_gap_qry, opt->bw, opt->max_chain_skip, opt->max_chain_iter, opt->min_cnt, opt->min_chain_score, opt->chain_gap_scale, is_splice, n_segs, n_a, a, &n_regs0, &u, b->km);
     .           		}
     .           	}
     3 ( 0.00%)  	b->frag_gap = max_chain_gap_ref;
     1 ( 0.00%)  	b->rep_len = rep_len;
     .           
     6 ( 0.00%)  	regs0 = mm_gen_regs(b->km, hash, qlen_sum, n_regs0, u, a);
 7,364 ( 0.01%)  => /home/kisliy/minimap2_v2.18/hit.c:mm_gen_regs (1x)
     4 ( 0.00%)  	if (mi->n_alt) {
     .           		mm_mark_alt(mi, n_regs0, regs0);
     .           		mm_hit_sort(b->km, &n_regs0, regs0, opt->alt_drop); // this step can be merged into mm_gen_regs(); will do if this shows up in profile
     .           	}
     .           
     2 ( 0.00%)  	if (mm_dbg_flag & MM_DBG_PRINT_SEED)
     .           		for (j = 0; j < n_regs0; ++j)
     .           			for (i = regs0[j].as; i < regs0[j].as + regs0[j].cnt; ++i)
     .           				fprintf(stderr, "CN\t%d\t%s\t%d\t%c\t%d\t%d\t%d\n", j, mi->seq[a[i].x<<1>>33].name, (int32_t)a[i].x, "+-"[a[i].x>>63], (int32_t)a[i].y, (int32_t)(a[i].y>>32&0xff),
     .           						i == regs0[j].as? 0 : ((int32_t)a[i].y - (int32_t)a[i-1].y) - ((int32_t)a[i].x - (int32_t)a[i-1].x));
     .           
     2 ( 0.00%)  	chain_post(opt, max_chain_gap_ref, mi, b->km, qlen_sum, n_segs, qlens, &n_regs0, regs0, a);
    13 ( 0.00%)  	if (!is_sr) mm_est_err(mi, qlen_sum, n_regs0, regs0, a, n_mini_pos, mini_pos);
71,867 ( 0.11%)  => /home/kisliy/minimap2_v2.18/esterr.c:mm_est_err (1x)
     .           
     2 ( 0.00%)  	if (n_segs == 1) { // uni-segment
     6 ( 0.00%)  		regs0 = align_regs(opt, mi, b->km, qlens[0], seqs[0], &n_regs0, regs0, a);
     9 ( 0.00%)  		mm_set_mapq(b->km, n_regs0, regs0, opt->min_chain_score, opt->a, rep_len, is_sr);
   985 ( 0.00%)  => /home/kisliy/minimap2_v2.18/hit.c:mm_set_mapq (1x)
     5 ( 0.00%)  		n_regs[0] = n_regs0, regs[0] = regs0;
     .           	} else { // multi-segment
     .           		mm_seg_t *seg;
     .           		seg = mm_seg_gen(b->km, hash, n_segs, qlens, n_regs0, regs0, n_regs, regs, a); // split fragment chain to separate segment chains
     .           		free(regs0);
     .           		for (i = 0; i < n_segs; ++i) {
     .           			mm_set_parent(b->km, opt->mask_level, opt->mask_len, n_regs[i], regs[i], opt->a * 2 + opt->b, opt->flag&MM_F_HARD_MLEVEL, opt->alt_drop); // update mm_reg1_t::parent
     .           			regs[i] = align_regs(opt, mi, b->km, qlens[i], seqs[i], &n_regs[i], regs[i], seg[i].a);
     .           			mm_set_mapq(b->km, n_regs[i], regs[i], opt->min_chain_score, opt->a, rep_len, is_sr);
     .           		}
     .           		mm_seg_free(b->km, n_segs, seg);
     .           		if (n_segs == 2 && opt->pe_ori >= 0 && (opt->flag&MM_F_CIGAR))
     .           			mm_pair(b->km, max_chain_gap_ref, opt->pe_bonus, opt->a * 2 + opt->b, opt->a, qlens, n_regs, regs); // pairing
     .           	}
     .           
     4 ( 0.00%)  	kfree(b->km, mv.a);
    58 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (1x)
     4 ( 0.00%)  	kfree(b->km, a);
    58 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (1x)
     4 ( 0.00%)  	kfree(b->km, u);
    45 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (1x)
     4 ( 0.00%)  	kfree(b->km, mini_pos);
    52 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (1x)
     .           
     4 ( 0.00%)  	if (b->km) {
     2 ( 0.00%)  		km_stat(b->km, &kmst);
    62 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:km_stat (1x)
     2 ( 0.00%)  		if (mm_dbg_flag & MM_DBG_PRINT_QNAME)
    11 ( 0.00%)  			fprintf(stderr, "QM\t%s\t%d\tcap=%ld,nCore=%ld,largest=%ld\n", qname, qlen_sum, kmst.capacity, kmst.n_cores, kmst.largest);
46,722,824 (74.48%)  => map.c:align_regs.part.5 (1x)
     3 ( 0.00%)  		assert(kmst.n_blocks == kmst.n_cores); // otherwise, there is a memory leak
     2 ( 0.00%)  		if (kmst.largest > 1U<<28) {
     .           			km_destroy(b->km);
     .           			b->km = km_init();
     .           		}
     .           	}
     8 ( 0.00%)  }
     .           
     .           mm_reg1_t *mm_map(const mm_idx_t *mi, int qlen, const char *seq, int *n_regs, mm_tbuf_t *b, const mm_mapopt_t *opt, const char *qname)
     .           {
     .           	mm_reg1_t *regs;
     .           	mm_map_frag(mi, 1, &qlen, &seq, n_regs, &regs, b, opt, qname);
     .           	return regs;
     .           }
     .           
-- line 400 ----------------------------------------
-- line 420 ----------------------------------------
     .               int n_seq, n_frag;
     .           	mm_bseq1_t *seq;
     .           	int *n_reg, *seg_off, *n_seg, *rep_len, *frag_gap;
     .           	mm_reg1_t **reg;
     .           	mm_tbuf_t **buf;
     .           } step_t;
     .           
     .           static void worker_for(void *_data, long i, int tid) // kt_for() callback
     9 ( 0.00%)  {
     .               step_t *s = (step_t*)_data;
     8 ( 0.00%)  	int qlens[MM_MAX_SEG], j, off = s->seg_off[i], pe_ori = s->p->opt->pe_ori;
     .           	const char *qseqs[MM_MAX_SEG];
     3 ( 0.00%)  	mm_tbuf_t *b = s->buf[tid];
     4 ( 0.00%)  	assert(s->n_seg[i] <= MM_MAX_SEG);
     2 ( 0.00%)  	if (mm_dbg_flag & MM_DBG_PRINT_QNAME)
     .           		fprintf(stderr, "QR\t%s\t%d\t%d\n", s->seq[off].name, tid, s->seq[off].l_seq);
    12 ( 0.00%)  	for (j = 0; j < s->n_seg[i]; ++j) {
    14 ( 0.00%)  		if (s->n_seg[i] == 2 && ((j == 0 && (pe_ori>>1&1)) || (j == 1 && (pe_ori&1))))
     .           			mm_revcomp_bseq(&s->seq[off + j]);
     3 ( 0.00%)  		qlens[j] = s->seq[off + j].l_seq;
     3 ( 0.00%)  		qseqs[j] = s->seq[off + j].seq;
     .           	}
     4 ( 0.00%)  	if (s->p->opt->flag & MM_F_INDEPEND_SEG) {
     .           		for (j = 0; j < s->n_seg[i]; ++j) {
     .           			mm_map_frag(s->p->mi, 1, &qlens[j], &qseqs[j], &s->n_reg[off+j], &s->reg[off+j], b, s->p->opt, s->seq[off+j].name);
     .           			s->rep_len[off + j] = b->rep_len;
     .           			s->frag_gap[off + j] = b->frag_gap;
     .           		}
     .           	} else {
    20 ( 0.00%)  		mm_map_frag(s->p->mi, s->n_seg[i], qlens, qseqs, &s->n_reg[off], &s->reg[off], b, s->p->opt, s->seq[off].name);
50,436,278 (80.40%)  => map.c:mm_map_frag (1x)
    15 ( 0.00%)  		for (j = 0; j < s->n_seg[i]; ++j) {
     3 ( 0.00%)  			s->rep_len[off + j] = b->rep_len;
     2 ( 0.00%)  			s->frag_gap[off + j] = b->frag_gap;
     .           		}
     .           	}
    15 ( 0.00%)  	for (j = 0; j < s->n_seg[i]; ++j) // flip the query strand and coordinate to the original read strand
    13 ( 0.00%)  		if (s->n_seg[i] == 2 && ((j == 0 && (pe_ori>>1&1)) || (j == 1 && (pe_ori&1)))) {
     .           			int k, t;
     .           			mm_revcomp_bseq(&s->seq[off + j]);
     .           			for (k = 0; k < s->n_reg[off + j]; ++k) {
     .           				mm_reg1_t *r = &s->reg[off + j][k];
     .           				t = r->qs;
     .           				r->qs = qlens[j] - r->qe;
     .           				r->qe = qlens[j] - t;
     .           				r->rev = !r->rev;
     .           			}
     .           		}
     8 ( 0.00%)  }
     .           
     .           static void merge_hits(step_t *s)
     .           {
     .           	int f, i, k0, k, max_seg = 0, *n_reg_part, *rep_len_part, *frag_gap_part, *qlens;
     .           	void *km;
     .           	FILE **fp = s->p->fp_parts;
     .           	const mm_mapopt_t *opt = s->p->opt;
     .           
-- line 475 ----------------------------------------
-- line 489 ----------------------------------------
     .           				mm_err_fread(&n_reg_part[j],    sizeof(int), 1, fp[j]);
     .           				mm_err_fread(&rep_len_part[j],  sizeof(int), 1, fp[j]);
     .           				mm_err_fread(&frag_gap_part[j], sizeof(int), 1, fp[j]);
     .           				s->n_reg[k] += n_reg_part[j];
     .           				if (rep_len < rep_len_part[j])
     .           					rep_len = rep_len_part[j];
     .           			}
     .           			s->reg[k] = CALLOC(mm_reg1_t, s->n_reg[k]);
     5 ( 0.00%)  			for (j = 0, l = 0; j < s->p->n_parts; ++j) {
     .           				for (t = 0; t < n_reg_part[j]; ++t, ++l) {
     .           					mm_reg1_t *r = &s->reg[k][l];
     .           					uint32_t capacity;
     .           					mm_err_fread(r, sizeof(mm_reg1_t), 1, fp[j]);
     .           					r->rid += s->p->rid_shift[j];
     .           					if (opt->flag & MM_F_CIGAR) {
     .           						mm_err_fread(&capacity, 4, 1, fp[j]);
     .           						r->p = (mm_extra_t*)calloc(capacity, 4);
-- line 505 ----------------------------------------
-- line 507 ----------------------------------------
     .           						mm_err_fread(r->p, r->p->capacity, 4, fp[j]);
     .           					}
     .           				}
     .           			}
     .           			mm_hit_sort(km, &s->n_reg[k], s->reg[k], opt->alt_drop);
     .           			mm_set_parent(km, opt->mask_level, opt->mask_len, s->n_reg[k], s->reg[k], opt->a * 2 + opt->b, opt->flag&MM_F_HARD_MLEVEL, opt->alt_drop);
     .           			if (!(opt->flag & MM_F_ALL_CHAINS)) {
     .           				mm_select_sub(km, opt->pri_ratio, s->p->mi->k*2, opt->best_n, &s->n_reg[k], s->reg[k]);
     1 ( 0.00%)  				mm_set_sam_pri(s->n_reg[k], s->reg[k]);
     .           			}
     .           			mm_set_mapq(km, s->n_reg[k], s->reg[k], opt->min_chain_score, opt->a, rep_len, !!(opt->flag & MM_F_SR));
     .           		}
     .           		if (s->n_seg[f] == 2 && opt->pe_ori >= 0 && (opt->flag&MM_F_CIGAR))
     .           			mm_pair(km, frag_gap_part[0], opt->pe_bonus, opt->a * 2 + opt->b, opt->a, qlens, &s->n_reg[k0], &s->reg[k0]);
     .           	}
     .           	free(qlens);
     .           	km_destroy(km);
     .           }
     .           
     .           static void *worker_pipeline(void *shared, int step, void *in)
    32 ( 0.00%)  {
     .           	int i, j, k;
     .               pipeline_t *p = (pipeline_t*)shared;
     8 ( 0.00%)      if (step == 0) { // step 0: read sequences
    14 ( 0.00%)  		int with_qual = (!!(p->opt->flag & MM_F_OUT_SAM) && !(p->opt->flag & MM_F_NO_QUAL));
     6 ( 0.00%)  		int with_comment = !!(p->opt->flag & MM_F_COPY_COMMENT);
    14 ( 0.00%)  		int frag_mode = (p->n_fp > 1 || !!(p->opt->flag & MM_F_FRAG_MODE));
     .                   step_t *s;
    10 ( 0.00%)          s = (step_t*)calloc(1, sizeof(step_t));
   442 ( 0.00%)  => ???:calloc (2x)
     .           		if (p->n_fp > 1) s->seq = mm_bseq_read_frag2(p->n_fp, p->fp, p->mini_batch_size, with_qual, with_comment, &s->n_seq);
    18 ( 0.00%)  		else s->seq = mm_bseq_read3(p->fp[0], p->mini_batch_size, with_qual, with_comment, frag_mode, &s->n_seq);
455,906 ( 0.73%)  => /home/kisliy/minimap2_v2.18/bseq.c:mm_bseq_read3 (2x)
     4 ( 0.00%)  		if (s->seq) {
     1 ( 0.00%)  			s->p = p;
     8 ( 0.00%)  			for (i = 0; i < s->n_seq; ++i)
     3 ( 0.00%)  				s->seq[i].rid = p->n_processed++;
     6 ( 0.00%)  			s->buf = (mm_tbuf_t**)calloc(p->n_threads, sizeof(mm_tbuf_t*));
   348 ( 0.00%)  => ???:calloc (1x)
     9 ( 0.00%)  			for (i = 0; i < p->n_threads; ++i)
     3 ( 0.00%)  				s->buf[i] = mm_tbuf_init();
   470 ( 0.00%)  => map.c:mm_tbuf_init (1x)
     6 ( 0.00%)  			s->n_reg = (int*)calloc(5 * s->n_seq, sizeof(int));
   220 ( 0.00%)  => ???:calloc (1x)
     5 ( 0.00%)  			s->seg_off = s->n_reg + s->n_seq; // seg_off, n_seg, rep_len and frag_gap are allocated together with n_reg
     2 ( 0.00%)  			s->n_seg = s->seg_off + s->n_seq;
     2 ( 0.00%)  			s->rep_len = s->n_seg + s->n_seq;
     2 ( 0.00%)  			s->frag_gap = s->rep_len + s->n_seq;
     4 ( 0.00%)  			s->reg = (mm_reg1_t**)calloc(s->n_seq, sizeof(mm_reg1_t*));
   219 ( 0.00%)  => ???:calloc (1x)
    16 ( 0.00%)  			for (i = 1, j = 0; i <= s->n_seq; ++i)
     2 ( 0.00%)  				if (i == s->n_seq || !frag_mode || !mm_qname_same(s->seq[i-1].name, s->seq[i].name)) {
     6 ( 0.00%)  					s->n_seg[s->n_frag] = i - j;
     5 ( 0.00%)  					s->seg_off[s->n_frag++] = j;
     .           					j = i;
     .           				}
     .           			return s;
     3 ( 0.00%)  		} else free(s);
    92 ( 0.00%)  => ???:free (1x)
     6 ( 0.00%)      } else if (step == 1) { // step 1: map
     3 ( 0.00%)  		if (p->n_parts > 0) merge_hits((step_t*)in);
     6 ( 0.00%)  		else kt_for(p->n_threads, worker_for, in, ((step_t*)in)->n_frag);
50,436,448 (80.40%)  => /home/kisliy/minimap2_v2.18/kthread.c:kt_for (1x)
     .           		return in;
     2 ( 0.00%)      } else if (step == 2) { // step 2: output
     1 ( 0.00%)  		void *km = 0;
     .                   step_t *s = (step_t*)in;
     2 ( 0.00%)  		const mm_idx_t *mi = p->mi;
    11 ( 0.00%)  		for (i = 0; i < p->n_threads; ++i) mm_tbuf_destroy(s->buf[i]);
   267 ( 0.00%)  => map.c:mm_tbuf_destroy (1x)
     3 ( 0.00%)  		free(s->buf);
    92 ( 0.00%)  => ???:free (1x)
     3 ( 0.00%)  		if ((p->opt->flag & MM_F_OUT_CS) && !(mm_dbg_flag & MM_DBG_NO_KALLOC)) km = km_init();
    10 ( 0.00%)  		for (k = 0; k < s->n_frag; ++k) {
     6 ( 0.00%)  			int seg_st = s->seg_off[k], seg_en = s->seg_off[k] + s->n_seg[k];
    17 ( 0.00%)  			for (i = seg_st; i < seg_en; ++i) {
     3 ( 0.00%)  				mm_bseq1_t *t = &s->seq[i];
     3 ( 0.00%)  				if (p->opt->split_prefix && p->n_parts == 0) { // then write to temporary files
     .           					mm_err_fwrite(&s->n_reg[i],    sizeof(int), 1, p->fp_split);
     .           					mm_err_fwrite(&s->rep_len[i],  sizeof(int), 1, p->fp_split);
     .           					mm_err_fwrite(&s->frag_gap[i], sizeof(int), 1, p->fp_split);
     .           					for (j = 0; j < s->n_reg[i]; ++j) {
     .           						mm_reg1_t *r = &s->reg[i][j];
     .           						mm_err_fwrite(r, sizeof(mm_reg1_t), 1, p->fp_split);
     .           						if (p->opt->flag & MM_F_CIGAR) {
     .           							mm_err_fwrite(&r->p->capacity, 4, 1, p->fp_split);
     .           							mm_err_fwrite(r->p, r->p->capacity, 4, p->fp_split);
     .           						}
     .           					}
     9 ( 0.00%)  				} else if (s->n_reg[i] > 0) { // the query has at least one hit
     5 ( 0.00%)  					for (j = 0; j < s->n_reg[i]; ++j) {
     3 ( 0.00%)  						mm_reg1_t *r = &s->reg[i][j];
     5 ( 0.00%)  						assert(!r->sam_pri || r->id == r->parent);
     4 ( 0.00%)  						if ((p->opt->flag & MM_F_NO_PRINT_2ND) && r->id != r->parent)
     .           							continue;
     2 ( 0.00%)  						if (p->opt->flag & MM_F_OUT_SAM)
    38 ( 0.00%)  							mm_write_sam3(&p->str, mi, t, i - seg_st, j, s->n_seg[k], &s->n_reg[seg_st], (const mm_reg1_t*const*)&s->reg[seg_st], km, p->opt->flag, s->rep_len[i]);
48,085 ( 0.08%)  => /home/kisliy/minimap2_v2.18/format.c:mm_write_sam3 (1x)
     .           						else
     .           							mm_write_paf3(&p->str, mi, t, r, km, p->opt->flag, s->rep_len[i]);
     4 ( 0.00%)  						mm_err_puts(p->str.s);
44,203 ( 0.07%)  => /home/kisliy/minimap2_v2.18/misc.c:mm_err_puts (1x)
     .           					}
     .           				} else if ((p->opt->flag & MM_F_PAF_NO_HIT) || ((p->opt->flag & MM_F_OUT_SAM) && !(p->opt->flag & MM_F_SAM_HIT_ONLY))) { // output an empty hit, if requested
     .           					if (p->opt->flag & MM_F_OUT_SAM)
     .           						mm_write_sam3(&p->str, mi, t, i - seg_st, -1, s->n_seg[k], &s->n_reg[seg_st], (const mm_reg1_t*const*)&s->reg[seg_st], km, p->opt->flag, s->rep_len[i]);
     .           					else
     2 ( 0.00%)  						mm_write_paf3(&p->str, mi, t, 0, 0, p->opt->flag, s->rep_len[i]);
     .           					mm_err_puts(p->str.s);
     .           				}
     .           			}
     2 ( 0.00%)  			for (i = seg_st; i < seg_en; ++i) {
    16 ( 0.00%)  				for (j = 0; j < s->n_reg[i]; ++j) free(s->reg[i][j].p);
   131 ( 0.00%)  => ???:free (1x)
     4 ( 0.00%)  				free(s->reg[i]);
    88 ( 0.00%)  => ???:free (1x)
     8 ( 0.00%)  				free(s->seq[i].seq); free(s->seq[i].name);
   204 ( 0.00%)  => ???:free (2x)
     5 ( 0.00%)  				if (s->seq[i].qual) free(s->seq[i].qual);
     6 ( 0.00%)  				if (s->seq[i].comment) free(s->seq[i].comment);
     .           			}
     .           		}
     9 ( 0.00%)  		free(s->reg); free(s->n_reg); free(s->seq); // seg_off, n_seg, rep_len and frag_gap were allocated with reg; no memory leak here
   318 ( 0.00%)  => ???:free (3x)
     2 ( 0.00%)  		km_destroy(km);
    10 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:km_destroy (1x)
     2 ( 0.00%)  		if (mm_verbose >= 3)
    19 ( 0.00%)  			fprintf(stderr, "[M::%s::%.3f*%.2f] mapped %d sequences\n", __func__, realtime() - mm_realtime0, cputime() / (realtime() - mm_realtime0), s->n_seq);
 3,958 ( 0.01%)  => ???:fprintf (1x)
    28 ( 0.00%)  => /home/kisliy/minimap2_v2.18/misc.c:realtime (2x)
    20 ( 0.00%)  => /home/kisliy/minimap2_v2.18/misc.c:cputime (1x)
     3 ( 0.00%)  		free(s);
    92 ( 0.00%)  => ???:free (1x)
     .           	}
     4 ( 0.00%)      return 0;
    32 ( 0.00%)  }
     .           
     .           static mm_bseq_file_t **open_bseqs(int n, const char **fn)
     7 ( 0.00%)  {
     .           	mm_bseq_file_t **fp;
     .           	int i, j;
     5 ( 0.00%)  	fp = (mm_bseq_file_t**)calloc(n, sizeof(mm_bseq_file_t*));
   227 ( 0.00%)  => ???:calloc (1x)
    10 ( 0.00%)  	for (i = 0; i < n; ++i) {
     6 ( 0.00%)  		if ((fp[i] = mm_bseq_open(fn[i])) == 0) {
 2,150 ( 0.00%)  => /home/kisliy/minimap2_v2.18/bseq.c:mm_bseq_open (1x)
     .           			if (mm_verbose >= 1)
     .           				fprintf(stderr, "ERROR: failed to open file '%s': %s\n", fn[i], strerror(errno));
     .           			for (j = 0; j < i; ++j)
     .           				mm_bseq_close(fp[j]);
     .           			free(fp);
     .           			return 0;
     .           		}
     .           	}
     1 ( 0.00%)  	return fp;
     6 ( 0.00%)  }
     .           
     .           int mm_map_file_frag(const mm_idx_t *idx, int n_segs, const char **fn, const mm_mapopt_t *opt, int n_threads)
     8 ( 0.00%)  {
     .           	int i, pl_threads;
     .           	pipeline_t pl;
     2 ( 0.00%)  	if (n_segs < 1) return -1;
    19 ( 0.00%)  	memset(&pl, 0, sizeof(pipeline_t));
     1 ( 0.00%)  	pl.n_fp = n_segs;
     4 ( 0.00%)  	pl.fp = open_bseqs(pl.n_fp, fn);
 2,412 ( 0.00%)  => map.c:open_bseqs (1x)
     2 ( 0.00%)  	if (pl.fp == 0) return -1;
     2 ( 0.00%)  	pl.opt = opt, pl.mi = idx;
     4 ( 0.00%)  	pl.n_threads = n_threads > 1? n_threads : 1;
     2 ( 0.00%)  	pl.mini_batch_size = opt->mini_batch_size;
     3 ( 0.00%)  	if (opt->split_prefix)
     .           		pl.fp_split = mm_split_init(opt->split_prefix, idx);
     3 ( 0.00%)  	pl_threads = n_threads == 1? 1 : (opt->flag&MM_F_2_IO_THREADS)? 3 : 2;
     4 ( 0.00%)  	kt_pipeline(pl_threads, worker_pipeline, &pl, 3);
 2,216 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kthread.c:kt_pipeline (1x)
     .           
     3 ( 0.00%)  	free(pl.str.s);
   514 ( 0.00%)  => ???:free (1x)
     3 ( 0.00%)  	if (pl.fp_split) fclose(pl.fp_split);
     9 ( 0.00%)  	for (i = 0; i < pl.n_fp; ++i)
     4 ( 0.00%)  		mm_bseq_close(pl.fp[i]);
 5,851 ( 0.01%)  => /home/kisliy/minimap2_v2.18/bseq.c:mm_bseq_close (1x)
     3 ( 0.00%)  	free(pl.fp);
    89 ( 0.00%)  => ???:free (1x)
     1 ( 0.00%)  	return 0;
     6 ( 0.00%)  }
     .           
     .           int mm_map_file(const mm_idx_t *idx, const char *fn, const mm_mapopt_t *opt, int n_threads)
     3 ( 0.00%)  {
     4 ( 0.00%)  	return mm_map_file_frag(idx, 1, &fn, opt, n_threads);
11,165 ( 0.02%)  => map.c:mm_map_file_frag (1x)
     2 ( 0.00%)  }
     .           
     .           int mm_split_merge(int n_segs, const char **fn, const mm_mapopt_t *opt, int n_split_idx)
     .           {
     .           	int i;
     .           	pipeline_t pl;
     .           	mm_idx_t *mi;
     .           	if (n_segs < 1 || n_split_idx < 1) return -1;
     .           	memset(&pl, 0, sizeof(pipeline_t));
-- line 677 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: kalloc.c
--------------------------------------------------------------------------------
Ir              

-- line 34 ----------------------------------------
     .           	fprintf(stderr, "%s\n", s);
     .           	abort();
     .           }
     .           
     .           void *km_init2(void *km_par, size_t min_core_size)
     .           {
     .           	kmem_t *km;
     .           	km = (kmem_t*)kcalloc(km_par, 1, sizeof(kmem_t));
     2 ( 0.00%)  	km->par = km_par;
     2 ( 0.00%)  	km->min_core_size = min_core_size > 0? min_core_size : 0x80000;
     .           	return (void*)km;
     .           }
     .           
     6 ( 0.00%)  void *km_init(void) { return km_init2(0, 0); }
     .           
     .           void km_destroy(void *_km)
    12 ( 0.00%)  {
     .           	kmem_t *km = (kmem_t*)_km;
     .           	void *km_par;
     .           	header_t *p, *q;
     6 ( 0.00%)  	if (km == NULL) return;
     2 ( 0.00%)  	km_par = km->par;
    10 ( 0.00%)  	for (p = km->core_head; p != NULL;) {
     2 ( 0.00%)  		q = p->ptr;
     4 ( 0.00%)  		kfree(km_par, p);
   102 ( 0.00%)  => kalloc.c:kfree (2x)
     .           		p = q;
     .           	}
     6 ( 0.00%)  	kfree(km_par, km);
   195 ( 0.00%)  => kalloc.c:kfree (2x)
    10 ( 0.00%)  }
     .           
     .           static header_t *morecore(kmem_t *km, size_t nu)
     .           {
     .           	header_t *q;
     .           	size_t bytes, *p;
    12 ( 0.00%)  	nu = (nu + 1 + (km->min_core_size - 1)) / km->min_core_size * km->min_core_size; /* the first +1 for core header */
     4 ( 0.00%)  	bytes = nu * sizeof(header_t);
     4 ( 0.00%)  	q = (header_t*)kmalloc(km->par, bytes);
   632 ( 0.00%)  => kalloc.c:kmalloc'2 (2x)
     4 ( 0.00%)  	if (!q) panic("[morecore] insufficient memory");
     8 ( 0.00%)  	q->ptr = km->core_head, q->size = nu, km->core_head = q;
     .           	p = (size_t*)(q + 1);
     4 ( 0.00%)  	*p = nu - 1; /* the size of the free block; -1 because the first unit is used for the core header */
     6 ( 0.00%)  	kfree(km, p + 1); /* initialize the new "core"; NB: the core header is not looped. */
    73 ( 0.00%)  => kalloc.c:kfree (2x)
     2 ( 0.00%)  	return km->loop_head;
     .           }
     .           
     .           void kfree(void *_km, void *ap) /* kfree() also adds a new core to the circular list */
17,209 ( 0.03%)  {
     .           	header_t *p, *q;
     .           	kmem_t *km = (kmem_t*)_km;
     .           	
34,418 ( 0.05%)  	if (!ap) return;
28,750 ( 0.05%)  	if (km == NULL) {
42,525 ( 0.07%)  		free(ap);
1,270,165 ( 2.02%)  => ???:free (14,175x)
     .           		return;
     .           	}
   200 ( 0.00%)  	p = (header_t*)((size_t*)ap - 1);
   200 ( 0.00%)  	p->size = *((size_t*)ap - 1);
     .           	/* Find the pointer that points to the block to be freed. The following loop can stop on two conditions:
     .           	 *
     .           	 * a) "p>q && p<q->ptr": @------#++++++++#+++++++@-------    @---------------#+++++++@-------
     .           	 *    (can also be in    |      |                |        -> |                       |
     .           	 *     two cores)        q      p           q->ptr           q                  q->ptr
     .           	 *
     .           	 *                       @--------    #+++++++++@--------    @--------    @------------------
     .           	 *                       |            |         |         -> |            |
-- line 98 ----------------------------------------
-- line 101 ----------------------------------------
     .           	 * b) "q>=q->ptr && (p>q || p<q->ptr)":  @-------#+++++   @--------#+++++++     @-------#+++++   @----------------
     .           	 *                                       |                |        |         -> |                |
     .           	 *                                  q->ptr                q        p       q->ptr                q
     .           	 *
     .           	 *                                       #+++++++@-----   #++++++++@-------     @-------------   #++++++++@-------
     .           	 *                                       |       |                 |         -> |                         |
     .           	 *                                       p  q->ptr                 q       q->ptr                         q
     .           	 */
 2,952 ( 0.00%)  	for (q = km->loop_head; !(p > q && p < q->ptr); q = q->ptr)
 3,764 ( 0.01%)  		if (q >= q->ptr && (p > q || p < q->ptr)) break;
 1,000 ( 0.00%)  	if (p + p->size == q->ptr) { /* two adjacent blocks, merge p and q->ptr (the 2nd and 4th cases) */
   222 ( 0.00%)  		p->size += q->ptr->size;
   148 ( 0.00%)  		p->ptr = q->ptr->ptr;
   128 ( 0.00%)  	} else if (p + p->size > q->ptr && q->ptr >= p) {
     .           		panic("[kfree] The end of the allocated block enters a free block.");
   126 ( 0.00%)  	} else p->ptr = q->ptr; /* backup q->ptr */
     .           
 1,200 ( 0.00%)  	if (q + q->size == p) { /* two adjacent blocks, merge q and p (the other two cases) */
   248 ( 0.00%)  		q->size += p->size;
   248 ( 0.00%)  		q->ptr = p->ptr;
   248 ( 0.00%)  		km->loop_head = q;
   154 ( 0.00%)  	} else if (q + q->size > p && p >= q) {
     .           		panic("[kfree] The end of a free block enters the allocated block.");
   152 ( 0.00%)  	} else km->loop_head = p, q->ptr = p; /* in two cores, cannot be merged; create a new block in the list */
20,243 ( 0.03%)  }
     .           
     .           void *kmalloc(void *_km, size_t n_bytes)
12,144 ( 0.02%)  {
     .           	kmem_t *km = (kmem_t*)_km;
     .           	size_t n_units;
     .           	header_t *p, *q;
     .           
 6,072 ( 0.01%)  	if (n_bytes == 0) return 0;
14,580 ( 0.02%)  	if (km == NULL) return malloc(n_bytes);
541,364 ( 0.86%)  => ???:malloc (2,834x)
   400 ( 0.00%)  	n_units = (n_bytes + sizeof(size_t) + sizeof(header_t) - 1) / sizeof(header_t); /* header+n_bytes requires at least this number of units */
     .           
   798 ( 0.00%)  	if (!(q = km->loop_head)) /* the first time when kmalloc() is called, intialize it */
    10 ( 0.00%)  		q = km->loop_head = km->base.ptr = &km->base;
   282 ( 0.00%)  	for (p = q->ptr;; q = p, p = p->ptr) { /* search for a suitable block */
 2,218 ( 0.00%)  		if (p->size >= n_units) { /* p->size if the size of current block. This line means the current block is large enough. */
   400 ( 0.00%)  			if (p->size == n_units) q->ptr = p->ptr; /* no need to split the block */
     .           			else { /* split the block. NB: memory is allocated at the end of the block! */
   400 ( 0.00%)  				p->size -= n_units; /* reduce the size of the free block */
   400 ( 0.00%)  				p += p->size; /* p points to the allocated block */
   200 ( 0.00%)  				*(size_t*)p = n_units; /* set the size */
     .           			}
   200 ( 0.00%)  			km->loop_head = q; /* set the end of chain */
   200 ( 0.00%)  			return (size_t*)p + 1;
     .           		}
   564 ( 0.00%)  		if (p == km->loop_head) { /* then ask for more "cores" */
     4 ( 0.00%)  			if ((p = morecore(km, n_units)) == 0) return 0;
     .           		}
     .           	}
 9,308 ( 0.01%)  }
     .           
     .           void *kcalloc(void *_km, size_t count, size_t size)
   168 ( 0.00%)  {
     .           	kmem_t *km = (kmem_t*)_km;
     .           	void *p;
14,450 ( 0.02%)  	if (size == 0 || count == 0) return 0;
17,124 ( 0.03%)  	if (km == NULL) return calloc(count, size);
657,555 ( 1.05%)  => ???:calloc (2,834x)
   280 ( 0.00%)  	p = kmalloc(km, count * size);
 1,904 ( 0.00%)  => kalloc.c:kmalloc (56x)
   280 ( 0.00%)  	memset(p, 0, count * size);
17,290 ( 0.03%)  => ???:__GI_memset (56x)
    56 ( 0.00%)  	return p;
   224 ( 0.00%)  }
     .           
     .           void *krealloc(void *_km, void *ap, size_t n_bytes) // TODO: this can be made more efficient in principle
59,710 ( 0.10%)  {
     .           	kmem_t *km = (kmem_t*)_km;
     .           	size_t cap, *p, *q;
     .           
17,060 ( 0.03%)  	if (n_bytes == 0) {
     .           		kfree(km, ap); return 0;
     .           	}
42,626 ( 0.07%)  	if (km == NULL) return realloc(ap, n_bytes);
1,892,313 ( 3.02%)  => ???:realloc (8,522x)
    25 ( 0.00%)  	if (ap == NULL) return kmalloc(km, n_bytes);
   881 ( 0.00%)  => kalloc.c:kmalloc (3x)
     .           	p = (size_t*)ap - 1;
    20 ( 0.00%)  	cap = (*p) * sizeof(header_t) - sizeof(size_t);
    10 ( 0.00%)  	if (cap >= n_bytes) return ap; /* TODO: this prevents shrinking */
    20 ( 0.00%)  	q = (size_t*)kmalloc(km, n_bytes);
   172 ( 0.00%)  => kalloc.c:kmalloc (5x)
    25 ( 0.00%)  	memcpy(q, ap, cap);
 6,262 ( 0.01%)  => ???:__memcpy_ssse3_back (5x)
    15 ( 0.00%)  	kfree(km, ap);
   236 ( 0.00%)  => kalloc.c:kfree (5x)
     5 ( 0.00%)  	return q;
42,660 ( 0.07%)  }
     .           
     .           void km_stat(const void *_km, km_stat_t *s)
     .           {
     .           	kmem_t *km = (kmem_t*)_km;
     .           	header_t *p;
     5 ( 0.00%)  	memset(s, 0, sizeof(km_stat_t));
     8 ( 0.00%)  	if (km == NULL || km->loop_head == NULL) return;
     .           	for (p = km->loop_head;; p = p->ptr) {
     8 ( 0.00%)  		s->available += p->size * sizeof(header_t);
     5 ( 0.00%)  		if (p->size != 0) ++s->n_blocks; /* &kmem_t::base is always one of the cores. It is zero-sized. */
    10 ( 0.00%)  		if (p->ptr > p && p + p->size > p->ptr)
     .           			panic("[km_stat] The end of a free block enters another free block.");
     4 ( 0.00%)  		if (p->ptr == km->loop_head) break;
     .           	}
    17 ( 0.00%)  	for (p = km->core_head; p != NULL; p = p->ptr) {
     2 ( 0.00%)  		size_t size = p->size * sizeof(header_t);
     .           		++s->n_cores;
     1 ( 0.00%)  		s->capacity += size;
     2 ( 0.00%)  		s->largest = s->largest > size? s->largest : size;
     .           	}
     .           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/emmintrin.h
--------------------------------------------------------------------------------
Ir                 

-- line 577 ----------------------------------------
        .           _mm_set_epi64 (__m64 __q1,  __m64 __q0)
        .           {
        .             return _mm_set_epi64x ((long long)__q1, (long long)__q0);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)
        .           {
  130,430 ( 0.21%)    return __extension__ (__m128i)(__v4si){ __q0, __q1, __q2, __q3 };
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_set_epi16 (short __q7, short __q6, short __q5, short __q4,
        .           	       short __q3, short __q2, short __q1, short __q0)
        .           {
        .             return __extension__ (__m128i)(__v8hi){
        .               __q0, __q1, __q2, __q3, __q4, __q5, __q6, __q7 };
-- line 593 ----------------------------------------
-- line 594 ----------------------------------------
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,
        .           	      char __q11, char __q10, char __q09, char __q08,
        .           	      char __q07, char __q06, char __q05, char __q04,
        .           	      char __q03, char __q02, char __q01, char __q00)
        .           {
  993,444 ( 1.58%)    return __extension__ (__m128i)(__v16qi){
        .               __q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07,
        .               __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15
        .             };
        .           }
        .           
        .           /* Set all of the elements of the vector to A.  */
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-- line 610 ----------------------------------------
-- line 676 ----------------------------------------
        .           _mm_load_si128 (__m128i const *__P)
        .           {
        .             return *__P;
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_loadu_si128 (__m128i const *__P)
        .           {
  706,480 ( 1.13%)    return (__m128i) __builtin_ia32_loaddqu ((char const *)__P);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_loadl_epi64 (__m128i const *__P)
        .           {
        .             return _mm_set_epi64 ((__m64)0LL, *(__m64 *)__P);
        .           }
        .           
        .           extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_store_si128 (__m128i *__P, __m128i __B)
        .           {
2,851,288 ( 4.54%)    *__P = __B;
        .           }
        .           
        .           extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_storeu_si128 (__m128i *__P, __m128i __B)
        .           {
1,058,939 ( 1.69%)    __builtin_ia32_storedqu ((char *)__P, (__v16qi)__B);
        .           }
        .           
        .           extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_storel_epi64 (__m128i *__P, __m128i __B)
        .           {
        .             *(long long *)__P = __builtin_ia32_vec_ext_v2di ((__v2di)__B, 0);
        .           }
        .           
-- line 710 ----------------------------------------
-- line 983 ----------------------------------------
        .           _mm_unpacklo_epi64 (__m128i __A, __m128i __B)
        .           {
        .             return (__m128i)__builtin_ia32_punpcklqdq128 ((__v2di)__A, (__v2di)__B);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_add_epi8 (__m128i __A, __m128i __B)
        .           {
2,494,877 ( 3.98%)    return (__m128i)__builtin_ia32_paddb128 ((__v16qi)__A, (__v16qi)__B);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_add_epi16 (__m128i __A, __m128i __B)
        .           {
        .             return (__m128i)__builtin_ia32_paddw128 ((__v8hi)__A, (__v8hi)__B);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_add_epi32 (__m128i __A, __m128i __B)
        .           {
    3,589 ( 0.01%)    return (__m128i)__builtin_ia32_paddd128 ((__v4si)__A, (__v4si)__B);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_add_epi64 (__m128i __A, __m128i __B)
        .           {
        .             return (__m128i)__builtin_ia32_paddq128 ((__v2di)__A, (__v2di)__B);
        .           }
        .           
-- line 1011 ----------------------------------------
-- line 1031 ----------------------------------------
        .           _mm_adds_epu16 (__m128i __A, __m128i __B)
        .           {
        .             return (__m128i)__builtin_ia32_paddusw128 ((__v8hi)__A, (__v8hi)__B);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_sub_epi8 (__m128i __A, __m128i __B)
        .           {
5,346,165 ( 8.52%)    return (__m128i)__builtin_ia32_psubb128 ((__v16qi)__A, (__v16qi)__B);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_sub_epi16 (__m128i __A, __m128i __B)
        .           {
        .             return (__m128i)__builtin_ia32_psubw128 ((__v8hi)__A, (__v8hi)__B);
        .           }
        .           
-- line 1047 ----------------------------------------
-- line 1152 ----------------------------------------
        .           _mm_bslli_si128 (__m128i __A, const int __N)
        .           {
        .             return (__m128i)__builtin_ia32_pslldqi128 (__A, __N * 8);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_srli_si128 (__m128i __A, const int __N)
        .           {
2,138,466 ( 3.41%)    return (__m128i)__builtin_ia32_psrldqi128 (__A, __N * 8);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_slli_si128 (__m128i __A, const int __N)
        .           {
1,425,644 ( 2.27%)    return (__m128i)__builtin_ia32_pslldqi128 (__A, __N * 8);
        .           }
        .           #else
        .           #define _mm_bsrli_si128(A, N) \
        .             ((__m128i)__builtin_ia32_psrldqi128 ((__m128i)(A), (int)(N) * 8))
        .           #define _mm_bslli_si128(A, N) \
        .             ((__m128i)__builtin_ia32_pslldqi128 ((__m128i)(A), (int)(N) * 8))
        .           #define _mm_srli_si128(A, N) \
        .             ((__m128i)__builtin_ia32_psrldqi128 ((__m128i)(A), (int)(N) * 8))
-- line 1174 ----------------------------------------
-- line 1240 ----------------------------------------
        .           _mm_srl_epi64 (__m128i __A, __m128i __B)
        .           {
        .             return (__m128i)__builtin_ia32_psrlq128 ((__v2di)__A, (__v2di)__B);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_and_si128 (__m128i __A, __m128i __B)
        .           {
3,201,066 ( 5.10%)    return (__m128i)__builtin_ia32_pand128 ((__v2di)__A, (__v2di)__B);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_andnot_si128 (__m128i __A, __m128i __B)
        .           {
   10,318 ( 0.02%)    return (__m128i)__builtin_ia32_pandn128 ((__v2di)__A, (__v2di)__B);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_or_si128 (__m128i __A, __m128i __B)
        .           {
2,844,528 ( 4.53%)    return (__m128i)__builtin_ia32_por128 ((__v2di)__A, (__v2di)__B);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_xor_si128 (__m128i __A, __m128i __B)
        .           {
        .             return (__m128i)__builtin_ia32_pxor128 ((__v2di)__A, (__v2di)__B);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_cmpeq_epi8 (__m128i __A, __m128i __B)
        .           {
2,097,906 ( 3.34%)    return (__m128i)__builtin_ia32_pcmpeqb128 ((__v16qi)__A, (__v16qi)__B);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_cmpeq_epi16 (__m128i __A, __m128i __B)
        .           {
        .             return (__m128i)__builtin_ia32_pcmpeqw128 ((__v8hi)__A, (__v8hi)__B);
        .           }
        .           
-- line 1280 ----------------------------------------
-- line 1300 ----------------------------------------
        .           _mm_cmplt_epi32 (__m128i __A, __m128i __B)
        .           {
        .             return (__m128i)__builtin_ia32_pcmpgtd128 ((__v4si)__B, (__v4si)__A);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_cmpgt_epi8 (__m128i __A, __m128i __B)
        .           {
6,579,220 (10.49%)    return (__m128i)__builtin_ia32_pcmpgtb128 ((__v16qi)__A, (__v16qi)__B);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_cmpgt_epi16 (__m128i __A, __m128i __B)
        .           {
        .             return (__m128i)__builtin_ia32_pcmpgtw128 ((__v8hi)__A, (__v8hi)__B);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_cmpgt_epi32 (__m128i __A, __m128i __B)
        .           {
    3,589 ( 0.01%)    return (__m128i)__builtin_ia32_pcmpgtd128 ((__v4si)__A, (__v4si)__B);
        .           }
        .           
        .           #ifdef __OPTIMIZE__
        .           extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_extract_epi16 (__m128i const __A, int const __N)
        .           {
        .             return (unsigned short) __builtin_ia32_vec_ext_v8hi ((__v8hi)__A, __N);
        .           }
-- line 1328 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: bseq.c
--------------------------------------------------------------------------------
Ir               

      .           #include <zlib.h>
      .           #include <stdio.h>
      .           #include <stdlib.h>
      .           #include <assert.h>
      .           #define __STDC_LIMIT_MACROS
      .           #include "bseq.h"
      .           #include "kvec.h"
      .           #include "kseq.h"
263,508 ( 0.42%)  KSEQ_INIT2(, gzFile, gzread)
  1,146 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
    462 ( 0.00%)  => ???:calloc (2x)
    360 ( 0.00%)  => ???:malloc (2x)
      .           
      .           unsigned char seq_comp_table[256] = {
      .           	  0,   1,	2,	 3,	  4,   5,	6,	 7,	  8,   9,  10,	11,	 12,  13,  14,	15,
      .           	 16,  17,  18,	19,	 20,  21,  22,	23,	 24,  25,  26,	27,	 28,  29,  30,	31,
      .           	 32,  33,  34,	35,	 36,  37,  38,	39,	 40,  41,  42,	43,	 44,  45,  46,	47,
      .           	 48,  49,  50,	51,	 52,  53,  54,	55,	 56,  57,  58,	59,	 60,  61,  62,	63,
      .           	 64, 'T', 'V', 'G', 'H', 'E', 'F', 'C', 'D', 'I', 'J', 'M', 'L', 'K', 'N', 'O',
      .           	'P', 'Q', 'Y', 'S', 'A', 'A', 'B', 'W', 'X', 'R', 'Z',	91,	 92,  93,  94,	95,
-- line 17 ----------------------------------------
-- line 31 ----------------------------------------
      .           
      .           struct mm_bseq_file_s {
      .           	gzFile fp;
      .           	kseq_t *ks;
      .           	mm_bseq1_t s;
      .           };
      .           
      .           mm_bseq_file_t *mm_bseq_open(const char *fn)
      6 ( 0.00%)  {
      .           	mm_bseq_file_t *fp;
      .           	gzFile f;
     22 ( 0.00%)  	f = fn && strcmp(fn, "-")? gzopen(fn, "r") : gzdopen(0, "r");
  7,789 ( 0.01%)  => ???:gzopen (2x)
    622 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
      4 ( 0.00%)  	if (f == 0) return 0;
     10 ( 0.00%)  	fp = (mm_bseq_file_t*)calloc(1, sizeof(mm_bseq_file_t));
    470 ( 0.00%)  => ???:calloc (2x)
      2 ( 0.00%)  	fp->fp = f;
      6 ( 0.00%)  	fp->ks = kseq_init(fp->fp);
  2,562 ( 0.00%)  => bseq.c:kseq_init (2x)
      2 ( 0.00%)  	return fp;
      8 ( 0.00%)  }
      .           
      .           void mm_bseq_close(mm_bseq_file_t *fp)
      4 ( 0.00%)  {
      4 ( 0.00%)  	kseq_destroy(fp->ks);
  1,440 ( 0.00%)  => bseq.c:kseq_destroy (2x)
     10 ( 0.00%)  	gzclose(fp->fp);
  4,978 ( 0.01%)  => ???:gzclose (2x)
    635 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
      6 ( 0.00%)  	free(fp);
    174 ( 0.00%)  => ???:free (2x)
      2 ( 0.00%)  }
      .           
      .           static inline char *kstrdup(const kstring_t *s)
      .           {
      .           	char *t;
     22 ( 0.00%)  	t = (char*)malloc(s->l + 1);
    947 ( 0.00%)  => ???:malloc (4x)
     20 ( 0.00%)  	memcpy(t, s->s, s->l + 1);
  5,250 ( 0.01%)  => ???:__memcpy_ssse3_back (4x)
      .           	return t;
      .           }
      .           
      .           static inline void kseq2bseq(kseq_t *ks, mm_bseq1_t *s, int with_qual, int with_comment)
      .           {
      .           	int i;
      6 ( 0.00%)  	if (ks->name.l == 0)
      .           		fprintf(stderr, "[WARNING]\033[1;31m empty sequence name in the input.\033[0m\n");
      2 ( 0.00%)  	s->name = kstrdup(&ks->name);
      2 ( 0.00%)  	s->seq = kstrdup(&ks->seq);
 99,210 ( 0.16%)  	for (i = 0; i < (int)ks->seq.l; ++i) // convert U to T
198,408 ( 0.32%)  		if (s->seq[i] == 'u' || s->seq[i] == 'U')
 66,136 ( 0.11%)  			--s->seq[i];
     14 ( 0.00%)  	s->qual = with_qual && ks->qual.l? kstrdup(&ks->qual) : 0;
     10 ( 0.00%)  	s->comment = with_comment && ks->comment.l? kstrdup(&ks->comment) : 0;
      6 ( 0.00%)  	s->l_seq = ks->seq.l;
      .           }
      .           
      .           mm_bseq1_t *mm_bseq_read3(mm_bseq_file_t *fp, int64_t chunk_size, int with_qual, int with_comment, int frag_mode, int *n_)
     52 ( 0.00%)  {
      8 ( 0.00%)  	int64_t size = 0;
      .           	int ret;
     12 ( 0.00%)  	kvec_t(mm_bseq1_t) a = {0,0,0};
      4 ( 0.00%)  	kseq_t *ks = fp->ks;
      4 ( 0.00%)  	*n_ = 0;
      8 ( 0.00%)  	if (fp->s.seq) {
      .           		kv_resize(mm_bseq1_t, 0, a, 256);
      .           		kv_push(mm_bseq1_t, 0, a, fp->s);
      .           		size = fp->s.l_seq;
     24 ( 0.00%)  		memset(&fp->s, 0, sizeof(mm_bseq1_t));
      .           	}
     24 ( 0.00%)  	while ((ret = kseq_read(ks)) >= 0) {
423,987 ( 0.68%)  => bseq.c:kseq_read (6x)
      .           		mm_bseq1_t *s;
      4 ( 0.00%)  		assert(ks->seq.l <= INT32_MAX);
     18 ( 0.00%)  		if (a.m == 0) kv_resize(mm_bseq1_t, 0, a, 256);
    496 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:krealloc (2x)
     10 ( 0.00%)  		kv_pushp(mm_bseq1_t, 0, a, &s);
      .           		kseq2bseq(ks, s, with_qual, with_comment);
      4 ( 0.00%)  		size += s->l_seq;
      4 ( 0.00%)  		if (size >= chunk_size) {
      4 ( 0.00%)  			if (frag_mode && a.a[a.n-1].l_seq < CHECK_PAIR_THRES) {
      .           				while ((ret = kseq_read(ks)) >= 0) {
      .           					kseq2bseq(ks, &fp->s, with_qual, with_comment);
      .           					if (mm_qname_same(fp->s.name, a.a[a.n-1].name)) {
      .           						kv_push(mm_bseq1_t, 0, a, fp->s);
      .           						memset(&fp->s, 0, sizeof(mm_bseq1_t));
      .           					} else break;
      .           				}
      .           			}
      .           			break;
      .           		}
      .           	}
      8 ( 0.00%)  	if (ret < -1) {
      .           		if (a.n) fprintf(stderr, "[WARNING]\033[1;31m failed to parse the FASTA/FASTQ record next to '%s'. Continue anyway.\033[0m\n", a.a[a.n-1].name);
      .           		else fprintf(stderr, "[WARNING]\033[1;31m failed to parse the first FASTA/FASTQ record. Continue anyway.\033[0m\n");
      .           	}
      8 ( 0.00%)  	*n_ = a.n;
      .           	return a.a;
     36 ( 0.00%)  }
      .           
      .           mm_bseq1_t *mm_bseq_read2(mm_bseq_file_t *fp, int64_t chunk_size, int with_qual, int frag_mode, int *n_)
      .           {
      6 ( 0.00%)  	return mm_bseq_read3(fp, chunk_size, with_qual, 0, frag_mode, n_);
338,842 ( 0.54%)  => bseq.c:mm_bseq_read3 (2x)
      .           }
      .           
      .           mm_bseq1_t *mm_bseq_read(mm_bseq_file_t *fp, int64_t chunk_size, int with_qual, int *n_)
      2 ( 0.00%)  {
      .           	return mm_bseq_read2(fp, chunk_size, with_qual, 0, n_);
      .           }
      .           
      .           mm_bseq1_t *mm_bseq_read_frag2(int n_fp, mm_bseq_file_t **fp, int64_t chunk_size, int with_qual, int with_comment, int *n_)
      .           {
      .           	int i;
      .           	int64_t size = 0;
      .           	kvec_t(mm_bseq1_t) a = {0,0,0};
-- line 135 ----------------------------------------
-- line 160 ----------------------------------------
      .           
      .           mm_bseq1_t *mm_bseq_read_frag(int n_fp, mm_bseq_file_t **fp, int64_t chunk_size, int with_qual, int *n_)
      .           {
      .           	return mm_bseq_read_frag2(n_fp, fp, chunk_size, with_qual, 0, n_);
      .           }
      .           
      .           int mm_bseq_eof(mm_bseq_file_t *fp)
      .           {
     27 ( 0.00%)  	return (ks_eof(fp->ks->f) && fp->s.seq == 0);
      3 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/smmintrin.h
--------------------------------------------------------------------------------
Ir                 

-- line 171 ----------------------------------------
        .           #define _mm_blend_epi16(X, Y, M)					\
        .             ((__m128i) __builtin_ia32_pblendw128 ((__v8hi)(__m128i)(X),		\
        .           					(__v8hi)(__m128i)(Y), (int)(M)))
        .           #endif
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_blendv_epi8 (__m128i __X, __m128i __Y, __m128i __M)
        .           {
2,129,786 ( 3.39%)    return (__m128i) __builtin_ia32_pblendvb128 ((__v16qi)__X,
        .           					       (__v16qi)__Y,
        .           					       (__v16qi)__M);
        .           }
        .           
        .           /* Single precision floating point blend instructions - select data
        .              from 2 sources using constant/variable mask.  */
        .           
        .           #ifdef __OPTIMIZE__
-- line 187 ----------------------------------------
-- line 268 ----------------------------------------
        .             return (__m128i) __builtin_ia32_pcmpeqq ((__v2di)__X, (__v2di)__Y);
        .           }
        .           
        .           /*  Min/max packed integer instructions.  */
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_min_epi8 (__m128i __X, __m128i __Y)
        .           {
  356,411 ( 0.57%)    return (__m128i) __builtin_ia32_pminsb128 ((__v16qi)__X, (__v16qi)__Y);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_max_epi8 (__m128i __X, __m128i __Y)
        .           {
1,425,644 ( 2.27%)    return (__m128i) __builtin_ia32_pmaxsb128 ((__v16qi)__X, (__v16qi)__Y);
        .           }
        .           
        .           extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
        .           _mm_min_epu16 (__m128i __X, __m128i __Y)
        .           {
        .             return (__m128i) __builtin_ia32_pminuw128 ((__v8hi)__X, (__v8hi)__Y);
        .           }
        .           
-- line 290 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: misc.c
--------------------------------------------------------------------------------
Ir               

-- line 89 ----------------------------------------
      .           }
      .           
      .           long peakrss(void) { return 0; }
      .           #else
      .           #include <sys/resource.h>
      .           #include <sys/time.h>
      .           
      .           double cputime(void)
      7 ( 0.00%)  {
      .           	struct rusage r;
     32 ( 0.00%)  	getrusage(RUSAGE_SELF, &r);
  1,196 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
     35 ( 0.00%)  => ???:getrusage (7x)
     56 ( 0.00%)  	return r.ru_utime.tv_sec + r.ru_stime.tv_sec + 1e-6 * (r.ru_utime.tv_usec + r.ru_stime.tv_usec);
     14 ( 0.00%)  }
      .           
      .           long peakrss(void)
      1 ( 0.00%)  {
      .           	struct rusage r;
      4 ( 0.00%)  	getrusage(RUSAGE_SELF, &r);
      5 ( 0.00%)  => ???:getrusage (1x)
      .           #ifdef __linux__
      2 ( 0.00%)  	return r.ru_maxrss * 1024;
      .           #else
      .           	return r.ru_maxrss;
      .           #endif
      2 ( 0.00%)  }
      .           
      .           #endif /* WIN32 || _WIN32 */
      .           
      .           double realtime(void)
     14 ( 0.00%)  {
      .           	struct timeval tp;
     60 ( 0.00%)  	gettimeofday(&tp, NULL);
  1,259 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
     42 ( 0.00%)  => /home/kisliy/valgrind/valgrind/coregrind/m_trampoline.S:vgPlain_amd64_linux_REDIR_FOR_vgettimeofday (14x)
     56 ( 0.00%)  	return tp.tv_sec + tp.tv_usec * 1e-6;
     28 ( 0.00%)  }
      .           
      .           void mm_err_puts(const char *str)
      2 ( 0.00%)  {
      .           	int ret;
      8 ( 0.00%)  	ret = puts(str);
 51,685 ( 0.08%)  => ???:puts (2x)
  1,121 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
      4 ( 0.00%)  	if (ret == EOF) {
      .           		perror("[ERROR] failed to write the results");
      .           		exit(EXIT_FAILURE);
      .           	}
      4 ( 0.00%)  }
      .           
      .           void mm_err_fwrite(const void *p, size_t size, size_t nitems, FILE *fp)
      .           {
      .           	int ret;
      .           	ret = fwrite(p, size, nitems, fp);
      .           	if (ret == EOF) {
      .           		perror("[ERROR] failed to write data");
      .           		exit(EXIT_FAILURE);
-- line 139 ----------------------------------------
-- line 148 ----------------------------------------
      .           		perror("[ERROR] failed to read data");
      .           		exit(EXIT_FAILURE);
      .           	}
      .           }
      .           
      .           #include "ksort.h"
      .           
      .           #define sort_key_128x(a) ((a).x)
168,762 ( 0.27%)  KRADIX_SORT_INIT(128x, mm128_t, sort_key_128x, 8) 
136,620 ( 0.22%)  => misc.c:rs_sort_128x (1x)
 17,955 ( 0.03%)  => misc.c:rs_insertsort_128x (2,836x)
      .           
      .           #define sort_key_64(x) (x)
     18 ( 0.00%)  KRADIX_SORT_INIT(64, uint64_t, sort_key_64, 8)
      8 ( 0.00%)  => misc.c:rs_insertsort_64 (2x)
      .           
 46,798 ( 0.07%)  KSORT_INIT_GENERIC(uint32_t)

--------------------------------------------------------------------------------
-- Auto-annotated source: esterr.c
--------------------------------------------------------------------------------
Ir              

     .           #include <math.h>
     .           #include <stdio.h>
     .           #include <stdlib.h>
     .           #include <assert.h>
     .           #include "mmpriv.h"
     .           
     .           static inline int32_t get_for_qpos(int32_t qlen, const mm128_t *a)
     .           {
 6,006 ( 0.01%)  	int32_t x = (int32_t)a->y;
     .           	int32_t q_span = a->y>>32 & 0xff;
 6,006 ( 0.01%)  	if (a->x>>63)
     4 ( 0.00%)  		x = qlen - 1 - (x + 1 - q_span); // revert the position to the forward strand of query
     .           	return x;
     .           }
     .           
     .           static int get_mini_idx(int qlen, const mm128_t *a, int32_t n, const uint64_t *mini_pos)
     .           {
     5 ( 0.00%)  	int32_t x, L = 0, R = n - 1;
     .           	x = get_for_qpos(qlen, a);
    23 ( 0.00%)  	while (L <= R) { // binary search
    55 ( 0.00%)  		int32_t m = ((uint64_t)L + R) >> 1;
    11 ( 0.00%)  		int32_t y = (int32_t)mini_pos[m];
    24 ( 0.00%)  		if (y < x) L = m + 1;
    17 ( 0.00%)  		else if (y > x) R = m - 1;
     .           		else return m;
     .           	}
     .           	return -1;
     .           }
     .           
     .           void mm_est_err(const mm_idx_t *mi, int qlen, int n_regs, mm_reg1_t *regs, const mm128_t *a, int32_t n, const uint64_t *mini_pos)
    11 ( 0.00%)  {
     .           	int i;
     .           	uint64_t sum_k = 0;
     .           	float avg_k;
     .           
     3 ( 0.00%)  	if (n == 0) return;
 6,217 ( 0.01%)  	for (i = 0; i < n; ++i)
 9,315 ( 0.01%)  		sum_k += mini_pos[i] >> 32 & 0xff;
     2 ( 0.00%)  	avg_k = (float)sum_k / n;
     .           
    11 ( 0.00%)  	for (i = 0; i < n_regs; ++i) {
     .           		mm_reg1_t *r = &regs[i];
     .           		int32_t st, en, j, k, n_match, n_tot, l_ref;
     1 ( 0.00%)  		r->div = -1.0f;
     3 ( 0.00%)  		if (r->cnt == 0) continue;
     7 ( 0.00%)  		st = en = get_mini_idx(qlen, r->rev? &a[r->as + r->cnt - 1] : &a[r->as], n, mini_pos);
     2 ( 0.00%)  		if (st < 0) {
     .           			if (mm_verbose >= 2)
     .           				fprintf(stderr, "[WARNING] logic inconsistency in mm_est_err(). Please contact the developer.\n");
     .           			continue;
     .           		}
     7 ( 0.00%)  		l_ref = mi->seq[r->rid].len;
18,024 ( 0.03%)  		for (k = 1, j = st + 1, n_match = 1; j < n && k < r->cnt; ++j) {
     .           			int32_t x;
18,016 ( 0.03%)  			x = get_for_qpos(qlen, r->rev? &a[r->as + r->cnt - 1 - k] : &a[r->as + k]);
 6,004 ( 0.01%)  			if (x == (int32_t)mini_pos[j])
 1,023 ( 0.00%)  				++k, en = j, ++n_match;
     .           		}
     .           		n_tot = en - st + 1;
     8 ( 0.00%)  		if (r->qs > avg_k && r->rs > avg_k) ++n_tot;
    11 ( 0.00%)  		if (qlen - r->qs > avg_k && l_ref - r->re > avg_k) ++n_tot;
    27 ( 0.00%)  		r->div = n_match >= n_tot? 0.0f : (float)(1.0 - pow((double)n_match / n_tot, 1.0 / avg_k));
   729 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
   287 ( 0.00%)  => ???:pow (1x)
     .           	}
     8 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: align.c
--------------------------------------------------------------------------------
Ir               

      .           #include <assert.h>
      .           #include <string.h>
      .           #include <stdlib.h>
      .           #include <math.h>
      .           #include "minimap.h"
      .           #include "mmpriv.h"
      .           #include "ksw2.h"
      .           
      8 ( 0.00%)  static void ksw_gen_simple_mat(int m, int8_t *mat, int8_t a, int8_t b, int8_t sc_ambi)
      .           {
      .           	int i, j;
      5 ( 0.00%)  	a = a < 0? -a : a;
      5 ( 0.00%)  	b = b > 0? -b : b;
      6 ( 0.00%)  	sc_ambi = sc_ambi > 0? -sc_ambi : sc_ambi;
     12 ( 0.00%)  	for (i = 0; i < m - 1; ++i) {
     32 ( 0.00%)  		for (j = 0; j < m - 1; ++j)
     80 ( 0.00%)  			mat[i * m + j] = i == j? a : b;
     12 ( 0.00%)  		mat[i * m + m - 1] = sc_ambi;
      .           	}
     10 ( 0.00%)  	for (j = 0; j < m; ++j)
     10 ( 0.00%)  		mat[(m - 1) * m + j] = sc_ambi;
      1 ( 0.00%)  }
      .           
      .           static inline void mm_seq_rev(uint32_t len, uint8_t *seq)
      .           {
      .           	uint32_t i;
      .           	uint8_t t;
    428 ( 0.00%)  	for (i = 0; i < len>>1; ++i)
  1,616 ( 0.00%)  		t = seq[i], seq[i] = seq[len - 1 - i], seq[len - 1 - i] = t;
      .           }
      .           
      .           static inline void update_max_zdrop(int32_t score, int i, int j, int32_t *max, int *max_i, int *max_j, int e, int *max_zdrop, int pos[2][2])
      .           {
 42,411 ( 0.07%)  	if (score < *max) {
 10,824 ( 0.02%)  		int li = i - *max_i;
 10,824 ( 0.02%)  		int lj = j - *max_j;
 32,472 ( 0.05%)  		int diff = li > lj? li - lj : lj - li;
 21,746 ( 0.03%)  		int z = *max - score - diff * e;
 22,133 ( 0.04%)  		if (z > *max_zdrop) {
      .           			*max_zdrop = z;
    227 ( 0.00%)  			pos[0][0] = *max_i, pos[0][1] = i;
    341 ( 0.00%)  			pos[1][0] = *max_j, pos[1][1] = j;
      .           		}
 42,116 ( 0.07%)  	} else *max = score, *max_i = i, *max_j = j;
      .           }
      .           
      .           static int mm_test_zdrop(void *km, const mm_mapopt_t *opt, const uint8_t *qseq, const uint8_t *tseq, uint32_t n_cigar, uint32_t *cigar, const int8_t *mat)
      .           {
      .           	uint32_t k;
    486 ( 0.00%)  	int32_t score = 0, max = INT32_MIN, max_i = -1, max_j = -1, i = 0, j = 0, max_zdrop = 0;
    270 ( 0.00%)  	int pos[2][2] = {{-1, -1}, {-1, -1}}, q_len, t_len;
      .           
      .           	// find the score and the region where score drops most along diagonal
  1,040 ( 0.00%)  	for (k = 0, score = 0; k < n_cigar; ++k) {
  1,250 ( 0.00%)  		uint32_t l, op = cigar[k]&0xf, len = cigar[k]>>4;
    500 ( 0.00%)  		if (op == 0) {
 33,510 ( 0.05%)  			for (l = 0; l < len; ++l) {
142,587 ( 0.23%)  				score += mat[tseq[i + l] * 5 + qseq[j + l]];
      .           				update_max_zdrop(score, i+l, j+l, &max, &max_i, &max_j, opt->e, &max_zdrop, pos);
      .           			}
    608 ( 0.00%)  			i += len, j += len;
    294 ( 0.00%)  		} else if (op == 1 || op == 2 || op == 3) {
    784 ( 0.00%)  			score -= opt->q + opt->e * len;
    346 ( 0.00%)  			if (op == 1) j += len; // insertion
     48 ( 0.00%)  			else i += len;         // deletion
      .           			update_max_zdrop(score, i, j, &max, &max_i, &max_j, opt->e, &max_zdrop, pos);
      .           		}
      .           	}
      .           
      .           	// test if there is an inversion in the most dropped region
      .           	q_len = pos[1][1] - pos[1][0], t_len = pos[0][1] - pos[0][0];
    270 ( 0.00%)  	if (!(opt->flag&(MM_F_SPLICE|MM_F_SR|MM_F_FOR_ONLY|MM_F_REV_ONLY)) && max_zdrop > opt->zdrop_inv && q_len < opt->max_gap && t_len < opt->max_gap) {
      .           		uint8_t *qseq2;
      .           		void *qp;
      .           		int q_off, t_off;
      .           		qseq2 = (uint8_t*)kmalloc(km, q_len);
      .           		for (i = 0; i < q_len; ++i) {
      .           			int c = qseq[pos[1][1] - i - 1];
      .           			qseq2[i] = c >= 4? 4 : 3 - c;
      .           		}
      .           		qp = ksw_ll_qinit(km, 2, q_len, qseq2, 5, mat);
      .           		score = ksw_ll_i16(qp, t_len, tseq + pos[0][0], opt->q, opt->e, &q_off, &t_off);
      .           		kfree(km, qseq2);
      .           		kfree(km, qp);
      .           		if (score >= opt->min_chain_score * opt->a && score >= opt->min_dp_max)
      .           			return 2; // there is a potential inversion
      .           	}
    162 ( 0.00%)  	return max_zdrop > opt->zdrop? 1 : 0;
      .           }
      .           
      .           static void mm_fix_cigar(mm_reg1_t *r, const uint8_t *qseq, const uint8_t *tseq, int *qshift, int *tshift)
      .           {
      .           	mm_extra_t *p = r->p;
      .           	int32_t toff = 0, qoff = 0, to_shrink = 0;
      .           	uint32_t k;
      .           	*qshift = *tshift = 0;
      9 ( 0.00%)  	if (p->n_cigar <= 1) return;
    406 ( 0.00%)  	for (k = 0; k < p->n_cigar; ++k) { // indel left alignment
    609 ( 0.00%)  		uint32_t op = p->cigar[k]&0xf, len = p->cigar[k]>>4;
    407 ( 0.00%)  		if (len == 0) to_shrink = 1;
    406 ( 0.00%)  		if (op == 0) {
    612 ( 0.00%)  			toff += len, qoff += len;
    303 ( 0.00%)  		} else if (op == 1 || op == 2) { // insertion or deletion
  1,721 ( 0.00%)  			if (k > 0 && k < p->n_cigar - 1 && (p->cigar[k-1]&0xf) == 0 && (p->cigar[k+1]&0xf) == 0) {
    202 ( 0.00%)  				int l, prev_len = p->cigar[k-1] >> 4;
    202 ( 0.00%)  				if (op == 1) {
    102 ( 0.00%)  					for (l = 0; l < prev_len; ++l)
    408 ( 0.00%)  						if (qseq[qoff - 1 - l] != qseq[qoff + len - 1 - l])
      .           							break;
      .           				} else {
    100 ( 0.00%)  					for (l = 0; l < prev_len; ++l)
    450 ( 0.00%)  						if (tseq[toff - 1 - l] != tseq[toff + len - 1 - l])
      .           							break;
      .           				}
      .           				if (l > 0)
      .           					p->cigar[k-1] -= l<<4, p->cigar[k+1] += l<<4, qoff -= l, toff -= l;
      .           				if (l == prev_len) to_shrink = 1;
      .           			}
    304 ( 0.00%)  			if (op == 1) qoff += len;
      .           			else toff += len;
      .           		} else if (op == 3) {
    150 ( 0.00%)  			toff += len;
      .           		}
      .           	}
     16 ( 0.00%)  	assert(qoff == r->qe - r->qs && toff == r->re - r->rs);
    808 ( 0.00%)  	for (k = 0; k < p->n_cigar - 2; ++k) { // fix CIGAR like 5I6D7I
  1,805 ( 0.00%)  		if ((p->cigar[k]&0xf) > 0 && (p->cigar[k]&0xf) + (p->cigar[k+1]&0xf) == 3) {
      .           			uint32_t l, s[3] = {0,0,0};
      .           			for (l = k; l < p->n_cigar; ++l) { // count number of adjacent I and D
      .           				uint32_t op = p->cigar[l]&0xf;
      .           				if (op == 1 || op == 2 || p->cigar[l]>>4 == 0)
      .           					s[op] += p->cigar[l] >> 4;
      .           				else break;
      .           			}
      .           			if (s[1] > 0 && s[2] > 0 && l - k > 2) { // turn to a single I and a single D
-- line 135 ----------------------------------------
-- line 137 ----------------------------------------
      .           				p->cigar[k+1] = s[2]<<4|2;
      .           				for (k += 2; k < l; ++k)
      .           					p->cigar[k] &= 0xf;
      .           				to_shrink = 1;
      .           			}
      .           			k = l;
      .           		}
      .           	}
      2 ( 0.00%)  	if (to_shrink) { // squeeze out zero-length operations
      .           		int32_t l = 0;
      .           		for (k = 0; k < p->n_cigar; ++k) // squeeze out zero-length operations
      .           			if (p->cigar[k]>>4 != 0)
      .           				p->cigar[l++] = p->cigar[k];
      .           		p->n_cigar = l;
      .           		for (k = l = 0; k < p->n_cigar; ++k) // merge two adjacent operations if they are the same
      .           			if (k == p->n_cigar - 1 || (p->cigar[k]&0xf) != (p->cigar[k+1]&0xf))
      .           				p->cigar[l++] = p->cigar[k];
      .           			else p->cigar[k+1] += p->cigar[k]>>4<<4; // add length to the next CIGAR operator
      .           		p->n_cigar = l;
      .           	}
      9 ( 0.00%)  	if ((p->cigar[0]&0xf) == 1 || (p->cigar[0]&0xf) == 2) { // get rid of leading I or D
      .           		int32_t l = p->cigar[0] >> 4;
      .           		if ((p->cigar[0]&0xf) == 1) {
      .           			if (r->rev) r->qe -= l;
      .           			else r->qs += l;
      .           			*qshift = l;
      .           		} else r->rs += l, *tshift = l;
      .           		--p->n_cigar;
      .           		memmove(p->cigar, p->cigar + 1, p->n_cigar * 4);
-- line 165 ----------------------------------------
-- line 233 ----------------------------------------
      .           		p->cigar[m++] = r->p->cigar[k];
      .           	}
      .           	p->n_cigar = m;
      .           	free(r->p);
      .           	r->p = p;
      .           }
      .           
      .           static void mm_update_extra(mm_reg1_t *r, const uint8_t *qseq, const uint8_t *tseq, const int8_t *mat, int8_t q, int8_t e, int is_eqx)
     12 ( 0.00%)  {
      .           	uint32_t k, l;
      5 ( 0.00%)  	int32_t s = 0, max = 0, qshift, tshift, toff = 0, qoff = 0;
      1 ( 0.00%)  	mm_extra_t *p = r->p;
      2 ( 0.00%)  	if (p == 0) return;
      .           	mm_fix_cigar(r, qseq, tseq, &qshift, &tshift);
      2 ( 0.00%)  	qseq += qshift, tseq += tshift; // qseq and tseq may be shifted due to the removal of leading I/D
      3 ( 0.00%)  	r->blen = r->mlen = 0;
    409 ( 0.00%)  	for (k = 0; k < p->n_cigar; ++k) {
    609 ( 0.00%)  		uint32_t op = p->cigar[k]&0xf, len = p->cigar[k]>>4;
    406 ( 0.00%)  		if (op == 0) { // match/mismatch
      .           			int n_ambi = 0, n_diff = 0;
 32,866 ( 0.05%)  			for (l = 0; l < len; ++l) {
 63,692 ( 0.10%)  				int cq = qseq[qoff + l], ct = tseq[toff + l];
 63,692 ( 0.10%)  				if (ct > 3 || cq > 3) ++n_ambi;
 79,615 ( 0.13%)  				else if (ct != cq) ++n_diff;
 63,692 ( 0.10%)  				s += mat[ct * 5 + cq];
 31,846 ( 0.05%)  				if (s < 0) s = 0;
 47,769 ( 0.08%)  				else max = max > s? max : s;
      .           			}
  1,632 ( 0.00%)  			r->blen += len - n_ambi, r->mlen += len - (n_ambi + n_diff), p->n_ambi += n_ambi;
    306 ( 0.00%)  			toff += len, qoff += len;
    202 ( 0.00%)  		} else if (op == 1) { // insertion
      .           			int n_ambi = 0;
    561 ( 0.00%)  			for (l = 0; l < len; ++l)
    408 ( 0.00%)  				if (qseq[qoff + l] > 3) ++n_ambi;
    612 ( 0.00%)  			r->blen += len - n_ambi, p->n_ambi += n_ambi;
    306 ( 0.00%)  			s -= q + e * len;
      .           			if (s < 0) s = 0;
    202 ( 0.00%)  			qoff += len;
    100 ( 0.00%)  		} else if (op == 2) { // deletion
      .           			int n_ambi = 0;
    440 ( 0.00%)  			for (l = 0; l < len; ++l)
    280 ( 0.00%)  				if (tseq[toff + l] > 3) ++n_ambi;
    600 ( 0.00%)  			r->blen += len - n_ambi, p->n_ambi += n_ambi;
    359 ( 0.00%)  			s -= q + e * len;
      .           			if (s < 0) s = 0;
     50 ( 0.00%)  			toff += len;
      .           		} else if (op == 3) { // intron
    101 ( 0.00%)  			toff += len;
      .           		}
      .           	}
      1 ( 0.00%)  	p->dp_max = max;
      7 ( 0.00%)  	assert(qoff == r->qe - r->qs && toff == r->re - r->rs);
      3 ( 0.00%)  	if (is_eqx) mm_update_cigar_eqx(r, qseq, tseq); // NB: it has to be called here as changes to qseq and tseq are not returned
      8 ( 0.00%)  }
      .           
    448 ( 0.00%)  static void mm_append_cigar(mm_reg1_t *r, uint32_t n_cigar, uint32_t *cigar) // TODO: this calls the libc realloc()
      .           {
      .           	mm_extra_t *p;
      .           	if (n_cigar == 0) return;
    168 ( 0.00%)  	if (r->p == 0) {
      .           		uint32_t capacity = n_cigar + sizeof(mm_extra_t)/4;
     17 ( 0.00%)  		kroundup32(capacity);
      6 ( 0.00%)  		r->p = (mm_extra_t*)calloc(capacity, 4);
    231 ( 0.00%)  => ???:calloc (1x)
      3 ( 0.00%)  		r->p->capacity = capacity;
    385 ( 0.00%)  	} else if (r->p->n_cigar + n_cigar + sizeof(mm_extra_t)/4 > r->p->capacity) {
      .           		r->p->capacity = r->p->n_cigar + n_cigar + sizeof(mm_extra_t)/4;
     72 ( 0.00%)  		kroundup32(r->p->capacity);
     32 ( 0.00%)  		r->p = (mm_extra_t*)realloc(r->p, r->p->capacity * 4);
    914 ( 0.00%)  => ???:realloc (4x)
      .           	}
      .           	p = r->p;
    607 ( 0.00%)  	if (p->n_cigar > 0 && (p->cigar[p->n_cigar-1]&0xf) == (cigar[0]&0xf)) { // same CIGAR op at the boundary
    165 ( 0.00%)  		p->cigar[p->n_cigar-1] += cigar[0]>>4<<4;
    278 ( 0.00%)  		if (n_cigar > 1) memcpy(p->cigar + p->n_cigar, cigar + 1, (n_cigar - 1) * 4);
    408 ( 0.00%)  => ???:__memcpy_ssse3_back (24x)
    110 ( 0.00%)  		p->n_cigar += n_cigar - 1;
      .           	} else {
      5 ( 0.00%)  		memcpy(p->cigar + p->n_cigar, cigar, n_cigar * 4);
     14 ( 0.00%)  => ???:__memcpy_ssse3_back (1x)
      1 ( 0.00%)  		p->n_cigar += n_cigar;
      .           	}
    336 ( 0.00%)  }
      .           
      .           static void mm_align_pair(void *km, const mm_mapopt_t *opt, int qlen, const uint8_t *qseq, int tlen, const uint8_t *tseq, const uint8_t *junc, const int8_t *mat, int w, int end_bonus, int zdrop, int flag, ksw_extz_t *ez)
  1,456 ( 0.00%)  {
    112 ( 0.00%)  	if (mm_dbg_flag & MM_DBG_PRINT_ALN_SEQ) {
      .           		int i;
      .           		fprintf(stderr, "===> q=(%d,%d), e=(%d,%d), bw=%d, flag=%d, zdrop=%d <===\n", opt->q, opt->q2, opt->e, opt->e2, w, flag, opt->zdrop);
      .           		for (i = 0; i < tlen; ++i) fputc("ACGTN"[tseq[i]], stderr);
      .           		fputc('\n', stderr);
      .           		for (i = 0; i < qlen; ++i) fputc("ACGTN"[qseq[i]], stderr);
    168 ( 0.00%)  		fputc('\n', stderr);
      .           	}
    168 ( 0.00%)  	if (opt->max_sw_mat > 0 && (int64_t)tlen * qlen > opt->max_sw_mat) {
      .           		ksw_reset_extz(ez);
      .           		ez->zdropped = 1;
    112 ( 0.00%)  	} else if (opt->flag & MM_F_SPLICE)
      .           		ksw_exts2_sse(km, qlen, qseq, tlen, tseq, 5, mat, opt->q, opt->e, opt->q2, opt->noncan, zdrop, opt->junc_bonus, flag, junc, ez);
    224 ( 0.00%)  	else if (opt->q == opt->q2 && opt->e == opt->e2)
      .           		ksw_extz2_sse(km, qlen, qseq, tlen, tseq, 5, mat, opt->q, opt->e, w, zdrop, end_bonus, flag, ez);
      .           	else
  1,456 ( 0.00%)  		ksw_extd2_sse(km, qlen, qseq, tlen, tseq, 5, mat, opt->q, opt->e, opt->q2, opt->e2, w, zdrop, end_bonus, flag, ez);
45,190,827 (72.03%)  => /home/kisliy/minimap2_v2.18/ksw2_dispatch.c:ksw_extd2_sse (56x)
    112 ( 0.00%)  	if (mm_dbg_flag & MM_DBG_PRINT_ALN_SEQ) {
      .           		int i;
      .           		fprintf(stderr, "score=%d, cigar=", ez->score);
      .           		for (i = 0; i < ez->n_cigar; ++i)
      .           			fprintf(stderr, "%d%c", ez->cigar[i]>>4, "MIDN"[ez->cigar[i]&0xf]);
      .           		fprintf(stderr, "\n");
      .           	}
    448 ( 0.00%)  }
      .           
      .           static inline int mm_get_hplen_back(const mm_idx_t *mi, uint32_t rid, uint32_t x)
      .           {
      .           	int64_t i, off0 = mi->seq[rid].offset, off = off0 + x;
      .           	int c = mm_seq4_get(mi->S, off);
      .           	for (i = off - 1; i >= off0; --i)
      .           		if (mm_seq4_get(mi->S, i) != c) break;
      .           	return (int)(off - i);
      .           }
      .           
      .           static inline void mm_adjust_minier(const mm_idx_t *mi, uint8_t *const qseq0[2], mm128_t *a, int32_t *r, int32_t *q)
      .           {
    685 ( 0.00%)  	if (mi->flag & MM_I_HPC) {
      .           		const uint8_t *qseq = qseq0[a->x>>63];
      .           		int i, c;
      .           		*q = (int32_t)a->y;
      .           		for (i = *q - 1, c = qseq[*q]; i > 0; --i)
      .           			if (qseq[i] != c) break;
      .           		*q = i + 1;
      .           		c = mm_get_hplen_back(mi, a->x<<1>>33, (int32_t)a->x);
      .           		*r = (int32_t)a->x + 1 - c;
      .           	} else {
  3,080 ( 0.00%)  		*r = (int32_t)a->x - (mi->k>>1);
  1,371 ( 0.00%)  		*q = (int32_t)a->y - (mi->k>>1);
      .           	}
      .           }
      .           
      .           static int *collect_long_gaps(void *km, int as1, int cnt1, mm128_t *a, int min_gap, int *n_)
     14 ( 0.00%)  {
      .           	int i, n, *K;
      2 ( 0.00%)  	*n_ = 0;
  1,372 ( 0.00%)  	for (i = 1, n = 0; i < cnt1; ++i) { // count the number of gaps longer than min_gap
  2,752 ( 0.00%)  		int gap = ((int32_t)a[as1 + i].y - a[as1 + i - 1].y) - ((int32_t)a[as1 + i].x - a[as1 + i - 1].x);
  3,412 ( 0.01%)  		if (gap < -min_gap || gap > min_gap) ++n;
      .           	}
      6 ( 0.00%)  	if (n <= 1) return 0;
      4 ( 0.00%)  	K = (int*)kmalloc(km, n * sizeof(int));
     34 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
  1,367 ( 0.00%)  	for (i = 1, n = 0; i < cnt1; ++i) { // store the positions of long gaps
  1,364 ( 0.00%)  		int gap = ((int32_t)a[as1 + i].y - a[as1 + i - 1].y) - ((int32_t)a[as1 + i].x - a[as1 + i - 1].x);
  1,364 ( 0.00%)  		if (gap < -min_gap || gap > min_gap)
      6 ( 0.00%)  			K[n++] = i;
      .           	}
      1 ( 0.00%)  	*n_ = n;
      .           	return K;
     12 ( 0.00%)  }
      .           
      .           static void mm_filter_bad_seeds(void *km, int as1, int cnt1, mm128_t *a, int min_gap, int diff_thres, int max_ext_len, int max_ext_cnt)
      .           {
      .           	int max_st, max_en, n, i, k, max, *K;
      9 ( 0.00%)  	K = collect_long_gaps(km, as1, cnt1, a, min_gap, &n);
  7,925 ( 0.01%)  => align.c:collect_long_gaps (1x)
     19 ( 0.00%)  	if (K == 0) return;
      .           	max = 0, max_st = max_en = -1;
      .           	for (k = 0;; ++k) { // traverse long gaps
      2 ( 0.00%)  		int gap, l, n_ins = 0, n_del = 0, qs, rs, max_diff = 0, max_diff_l = -1;
     15 ( 0.00%)  		if (k == n || k >= max_en) {
      9 ( 0.00%)  			if (max_en > 0)
      .           				for (i = K[max_st]; i < K[max_en]; ++i)
      .           					a[as1 + i].y |= MM_SEED_IGNORE;
      8 ( 0.00%)  			max = 0, max_st = max_en = -1;
      6 ( 0.00%)  			if (k == n) break;
      .           		}
      .           		i = K[k];
     30 ( 0.00%)  		gap = ((int32_t)a[as1 + i].y - (int32_t)a[as1 + i - 1].y) - (int32_t)(a[as1 + i].x - a[as1 + i - 1].x);
      4 ( 0.00%)  		if (gap > 0) n_ins += gap;
      .           		else n_del += -gap;
      .           		qs = (int32_t)a[as1 + i - 1].y;
      2 ( 0.00%)  		rs = (int32_t)a[as1 + i - 1].x;
     23 ( 0.00%)  		for (l = k + 1; l < n && l <= k + max_ext_cnt; ++l) {
      .           			int j = K[l], diff;
     11 ( 0.00%)  			if ((int32_t)a[as1 + j].y - qs > max_ext_len || (int32_t)a[as1 + j].x - rs > max_ext_len) break;
      .           			gap = ((int32_t)a[as1 + j].y - (int32_t)a[as1 + j - 1].y) - (int32_t)(a[as1 + j].x - a[as1 + j - 1].x);
      .           			if (gap > 0) n_ins += gap;
      .           			else n_del += -gap;
      .           			diff = n_ins + n_del - abs(n_ins - n_del);
      .           			if (max_diff < diff)
      .           				max_diff = diff, max_diff_l = l;
      .           		}
      .           		if (max_diff > diff_thres && max_diff > max)
      .           			max = max_diff, max_st = k, max_en = max_diff_l;
      .           	}
      3 ( 0.00%)  	kfree(km, K);
     42 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (1x)
      .           }
      .           
      .           static void mm_filter_bad_seeds_alt(void *km, int as1, int cnt1, mm128_t *a, int min_gap, int max_ext)
      .           {
      .           	int n, k, *K;
      9 ( 0.00%)  	K = collect_long_gaps(km, as1, cnt1, a, min_gap, &n);
  3,785 ( 0.01%)  => align.c:collect_long_gaps (1x)
      2 ( 0.00%)  	if (K == 0) return;
      .           	for (k = 0; k < n;) {
      .           		int i = K[k], l;
      .           		int gap1 = ((int32_t)a[as1 + i].y - (int32_t)a[as1 + i - 1].y) - ((int32_t)a[as1 + i].x - (int32_t)a[as1 + i - 1].x);
      .           		int re1 = (int32_t)a[as1 + i].x;
      .           		int qe1 = (int32_t)a[as1 + i].y;
      .           		gap1 = gap1 > 0? gap1 : -gap1;
      .           		for (l = k + 1; l < n; ++l) {
      .           			int j = K[l], gap2, q_span_pre, rs2, qs2, m;
-- line 435 ----------------------------------------
-- line 454 ----------------------------------------
      .           		k = l;
      .           	}
      .           	kfree(km, K);
      .           }
      .           
      .           static void mm_fix_bad_ends(const mm_reg1_t *r, const mm128_t *a, int bw, int min_match, int32_t *as, int32_t *cnt)
      .           {
      .           	int32_t i, l, m;
      5 ( 0.00%)  	*as = r->as, *cnt = r->cnt;
      2 ( 0.00%)  	if (r->cnt < 3) return;
     12 ( 0.00%)  	m = l = a[r->as].y >> 32 & 0xff;
    202 ( 0.00%)  	for (i = r->as + 1; i < r->as + r->cnt - 1; ++i) {
      .           		int32_t lq, lr, min, max;
    462 ( 0.00%)  		int32_t q_span = a[i].y >> 32 & 0xff;
    138 ( 0.00%)  		if (a[i].y & MM_SEED_LONG_JOIN) break;
    264 ( 0.00%)  		lr = (int32_t)a[i].x - (int32_t)a[i-1].x;
    132 ( 0.00%)  		lq = (int32_t)a[i].y - (int32_t)a[i-1].y;
    198 ( 0.00%)  		min = lr < lq? lr : lq;
     66 ( 0.00%)  		max = lr > lq? lr : lq;
    462 ( 0.00%)  		if (max - min > l >> 1) *as = i;
     66 ( 0.00%)  		l += min;
    198 ( 0.00%)  		m += min < q_span? min : q_span;
    595 ( 0.00%)  		if (l >= bw << 1 || (m >= min_match && m >= bw) || m >= r->mlen >> 1) break;
      .           	}
      4 ( 0.00%)  	*cnt = r->as + r->cnt - *as;
      6 ( 0.00%)  	m = l = a[r->as + r->cnt - 1].y >> 32 & 0xff;
     17 ( 0.00%)  	for (i = r->as + r->cnt - 2; i > *as; --i) {
      .           		int32_t lq, lr, min, max;
     79 ( 0.00%)  		int32_t q_span = a[i+1].y >> 32 & 0xff;
     24 ( 0.00%)  		if (a[i+1].y & MM_SEED_LONG_JOIN) break;
     32 ( 0.00%)  		lr = (int32_t)a[i+1].x - (int32_t)a[i].x;
      8 ( 0.00%)  		lq = (int32_t)a[i+1].y - (int32_t)a[i].y;
     24 ( 0.00%)  		min = lr < lq? lr : lq;
      8 ( 0.00%)  		max = lr > lq? lr : lq;
     40 ( 0.00%)  		if (max - min > l >> 1) *cnt = i + 1 - *as;
      8 ( 0.00%)  		l += min;
     24 ( 0.00%)  		m += min < q_span? min : q_span;
     68 ( 0.00%)  		if (l >= bw << 1 || (m >= min_match && m >= bw) || m >= r->mlen >> 1) break;
      .           	}
      .           }
      .           
      .           static void mm_max_stretch(const mm_reg1_t *r, const mm128_t *a, int32_t *as, int32_t *cnt)
      .           {
      .           	int32_t i, score, max_score, len, max_i, max_len;
      .           
      .           	*as = r->as, *cnt = r->cnt;
-- line 499 ----------------------------------------
-- line 558 ----------------------------------------
      .           	if ((a[r->as + r->cnt - 1].y>>32&0xff) < log_gap + opt->anchor_ext_shift) {
      .           		score = mm_seed_ext_score(km, opt, mi, mat, qlen, qseq0, &a[r->as + r->cnt - 1]);
      .           		if ((double)score / mat[0] < log_gap + opt->anchor_ext_shift)
      .           			--(*cnt1);
      .           	}
      .           }
      .           
      .           static void mm_align1(void *km, const mm_mapopt_t *opt, const mm_idx_t *mi, int qlen, uint8_t *qseq0[2], mm_reg1_t *r, mm_reg1_t *r2, int n_a, mm128_t *a, ksw_extz_t *ez, int splice_flag)
     13 ( 0.00%)  {
      7 ( 0.00%)  	int is_sr = !!(opt->flag & MM_F_SR), is_splice = !!(opt->flag & MM_F_SPLICE);
     14 ( 0.00%)  	int32_t rid = a[r->as].x<<1>>33, rev = a[r->as].x>>63, as1, cnt1;
      .           	uint8_t *tseq, *qseq, *junc;
      1 ( 0.00%)  	int32_t i, l, bw, dropped = 0, extra_flag = 0, rs0, re0, qs0, qe0;
      .           	int32_t rs, re, qs, qe;
      .           	int32_t rs1, qs1, re1, qe1;
      .           	int8_t mat[25];
      .           
      4 ( 0.00%)  	if (is_sr) assert(!(mi->flag & MM_I_HPC)); // HPC won't work with SR because with HPC we can't easily tell if there is a gap
      .           
      2 ( 0.00%)  	r2->cnt = 0;
      4 ( 0.00%)  	if (r->cnt == 0) return;
      6 ( 0.00%)  	ksw_gen_simple_mat(5, mat, opt->a, opt->b, opt->sc_ambi);
    181 ( 0.00%)  => align.c:ksw_gen_simple_mat.constprop.9 (1x)
      6 ( 0.00%)  	bw = (int)(opt->bw * 1.5 + 1.);
      .           
      3 ( 0.00%)  	if (is_sr && !(mi->flag & MM_I_HPC)) {
      .           		mm_max_stretch(r, a, &as1, &cnt1);
      .           		rs = (int32_t)a[as1].x + 1 - (int32_t)(a[as1].y>>32&0xff);
      .           		qs = (int32_t)a[as1].y + 1 - (int32_t)(a[as1].y>>32&0xff);
      .           		re = (int32_t)a[as1+cnt1-1].x + 1;
      .           		qe = (int32_t)a[as1+cnt1-1].y + 1;
      .           	} else {
      5 ( 0.00%)  		if (!(opt->flag & MM_F_NO_END_FLT)) {
      3 ( 0.00%)  			if (is_splice)
      .           				mm_fix_bad_ends_splice(km, opt, mi, r, mat, qlen, qseq0, a, &as1, &cnt1);
      .           			else
      3 ( 0.00%)  				mm_fix_bad_ends(r, a, opt->bw, opt->min_chain_score * 2, &as1, &cnt1);
      .           		} else as1 = r->as, cnt1 = r->cnt;
      3 ( 0.00%)  		mm_filter_bad_seeds(km, as1, cnt1, a, 10, 40, opt->max_gap>>1, 10);
      3 ( 0.00%)  		mm_filter_bad_seeds_alt(km, as1, cnt1, a, 30, opt->max_gap>>1);
      .           		mm_adjust_minier(mi, qseq0, &a[as1], &rs, &qs);
      6 ( 0.00%)  		mm_adjust_minier(mi, qseq0, &a[as1 + cnt1 - 1], &re, &qe);
      .           	}
      3 ( 0.00%)  	assert(cnt1 > 0);
      .           
      3 ( 0.00%)  	if (is_splice) {
      .           		if (splice_flag & MM_F_SPLICE_FOR) extra_flag |= rev? KSW_EZ_SPLICE_REV : KSW_EZ_SPLICE_FOR;
      .           		if (splice_flag & MM_F_SPLICE_REV) extra_flag |= rev? KSW_EZ_SPLICE_FOR : KSW_EZ_SPLICE_REV;
      .           		if (opt->flag & MM_F_SPLICE_FLANK) extra_flag |= KSW_EZ_SPLICE_FLANK;
      .           	}
      .           
      .           	/* Look for the start and end of regions to perform DP. This sounds easy
      .           	 * but is in fact tricky. Excessively small regions lead to unnecessary
      .           	 * clippings and lose alignable sequences. Excessively large regions
      .           	 * occasionally lead to large overlaps between two chains and may cause
      .           	 * loss of alignments in corner cases. */
      3 ( 0.00%)  	if (is_sr) {
      .           		qs0 = 0, qe0 = qlen;
      .           		l = qs;
      .           		l += l * opt->a + opt->end_bonus > opt->q? (l * opt->a + opt->end_bonus - opt->q) / opt->e : 0;
      .           		rs0 = rs - l > 0? rs - l : 0;
      .           		l = qlen - qe;
      .           		l += l * opt->a + opt->end_bonus > opt->q? (l * opt->a + opt->end_bonus - opt->q) / opt->e : 0;
      .           		re0 = re + l < (int32_t)mi->seq[rid].len? re + l : mi->seq[rid].len;
      .           	} else {
      .           		// compute rs0 and qs0
     16 ( 0.00%)  		rs0 = (int32_t)a[r->as].x + 1 - (int32_t)(a[r->as].y>>32&0xff);
      1 ( 0.00%)  		qs0 = (int32_t)a[r->as].y + 1 - (int32_t)(a[r->as].y>>32&0xff);
      .           		if (rs0 < 0) rs0 = 0; // this may happen when HPC is in use
      2 ( 0.00%)  		assert(qs0 >= 0); // this should never happen, or it is logic error
      2 ( 0.00%)  		rs1 = qs1 = 0;
      3 ( 0.00%)  		for (i = r->as - 1, l = 0; i >= 0 && a[i].x>>32 == a[r->as].x>>32; --i) { // inspect nearby seeds
      .           			int32_t x = (int32_t)a[i].x + 1 - (int32_t)(a[i].y>>32&0xff);
      .           			int32_t y = (int32_t)a[i].y + 1 - (int32_t)(a[i].y>>32&0xff);
      .           			if (x < rs0 && y < qs0) {
      .           				if (++l > opt->min_cnt) {
      .           					l = rs0 - x > qs0 - y? rs0 - x : qs0 - y;
      .           					rs1 = rs0 - l, qs1 = qs0 - l;
      .           					if (rs1 < 0) rs1 = 0; // not strictly necessary; better have this guard for explicit
      .           					break;
      .           				}
      .           			}
      .           		}
      6 ( 0.00%)  		if (qs > 0 && rs > 0) {
      5 ( 0.00%)  			l = qs < opt->max_gap? qs : opt->max_gap;
      3 ( 0.00%)  			qs1 = qs1 > qs - l? qs1 : qs - l;
      3 ( 0.00%)  			qs0 = qs0 < qs1? qs0 : qs1; // at least include qs0
     13 ( 0.00%)  			l += l * opt->a > opt->q? (l * opt->a - opt->q) / opt->e : 0;
      3 ( 0.00%)  			l = l < opt->max_gap? l : opt->max_gap;
      2 ( 0.00%)  			l = l < rs? l : rs;
      4 ( 0.00%)  			rs1 = rs1 > rs - l? rs1 : rs - l;
      2 ( 0.00%)  			rs0 = rs0 < rs1? rs0 : rs1;
      3 ( 0.00%)  			rs0 = rs0 < rs? rs0 : rs;
      .           		} else rs0 = rs, qs0 = qs;
      .           		// compute re0 and qe0
     10 ( 0.00%)  		re0 = (int32_t)a[r->as + r->cnt - 1].x + 1;
      2 ( 0.00%)  		qe0 = (int32_t)a[r->as + r->cnt - 1].y + 1;
      7 ( 0.00%)  		re1 = mi->seq[rid].len, qe1 = qlen;
      3 ( 0.00%)  		for (i = r->as + r->cnt, l = 0; i < n_a && a[i].x>>32 == a[r->as].x>>32; ++i) { // inspect nearby seeds
      .           			int32_t x = (int32_t)a[i].x + 1;
      .           			int32_t y = (int32_t)a[i].y + 1;
      .           			if (x > re0 && y > qe0) {
      .           				if (++l > opt->min_cnt) {
      .           					l = x - re0 > y - qe0? x - re0 : y - qe0;
      .           					re1 = re0 + l, qe1 = qe0 + l;
      .           					break;
      .           				}
      .           			}
      .           		}
      4 ( 0.00%)  		if (qe < qlen && re < (int32_t)mi->seq[rid].len) {
      7 ( 0.00%)  			l = qlen - qe < opt->max_gap? qlen - qe : opt->max_gap;
      3 ( 0.00%)  			qe1 = qe1 < qe + l? qe1 : qe + l;
      3 ( 0.00%)  			qe0 = qe0 > qe1? qe0 : qe1; // at least include qe0
     13 ( 0.00%)  			l += l * opt->a > opt->q? (l * opt->a - opt->q) / opt->e : 0;
      2 ( 0.00%)  			l = l < opt->max_gap? l : opt->max_gap;
      3 ( 0.00%)  			l = l < (int32_t)mi->seq[rid].len - re? l : mi->seq[rid].len - re;
      3 ( 0.00%)  			re1 = re1 < re + l? re1 : re + l;
      4 ( 0.00%)  			re0 = re0 > re1? re0 : re1;
      .           		} else re0 = re, qe0 = qe;
      .           	}
      3 ( 0.00%)  	if (a[r->as].y & MM_SEED_SELF) {
      .           		int max_ext = r->qs > r->rs? r->qs - r->rs : r->rs - r->qs;
      .           		if (r->rs - rs0 > max_ext) rs0 = r->rs - max_ext;
      .           		if (r->qs - qs0 > max_ext) qs0 = r->qs - max_ext;
      .           		max_ext = r->qe > r->re? r->qe - r->re : r->re - r->qe;
      .           		if (re0 - r->re > max_ext) re0 = r->re + max_ext;
      .           		if (qe0 - r->qe > max_ext) qe0 = r->qe + max_ext;
      .           	}
      .           
      2 ( 0.00%)  	assert(re0 > rs0);
      8 ( 0.00%)  	tseq = (uint8_t*)kmalloc(km, re0 - rs0);
     34 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
      4 ( 0.00%)  	junc = (uint8_t*)kmalloc(km, re0 - rs0);
     50 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
      .           
      6 ( 0.00%)  	if (qs > 0 && rs > 0) { // left extension; probably the condition can be changed to "qs > qs0 && rs > rs0"
      4 ( 0.00%)  		qseq = &qseq0[rev][qs0];
      6 ( 0.00%)  		mm_idx_getseq(mi, rid, rs0, rs, tseq);
  1,764 ( 0.00%)  => /home/kisliy/minimap2_v2.18/index.c:mm_idx_getseq (1x)
      6 ( 0.00%)  		mm_idx_bed_junc(mi, rid, rs0, rs, junc);
     58 ( 0.00%)  => /home/kisliy/minimap2_v2.18/index.c:mm_idx_bed_junc (1x)
      3 ( 0.00%)  		mm_seq_rev(qs - qs0, qseq);
      2 ( 0.00%)  		mm_seq_rev(rs - rs0, tseq);
      .           		mm_seq_rev(rs - rs0, junc);
     24 ( 0.00%)  		mm_align_pair(km, opt, qs - qs0, qseq, rs - rs0, tseq, junc, mat, bw, opt->end_bonus, r->split_inv? opt->zdrop_inv : opt->zdrop, extra_flag|KSW_EZ_EXTZ_ONLY|KSW_EZ_RIGHT|KSW_EZ_REV_CIGAR, ez);
207,253 ( 0.33%)  => align.c:mm_align_pair (1x)
      9 ( 0.00%)  		if (ez->n_cigar > 0) {
    296 ( 0.00%)  => align.c:mm_append_cigar.isra.4.part.5 (1x)
      .           			mm_append_cigar(r, ez->n_cigar, ez->cigar);
      5 ( 0.00%)  			r->p->dp_score += ez->max;
      .           		}
     10 ( 0.00%)  		rs1 = rs - (ez->reach_end? ez->mqe_t + 1 : ez->max_t + 1);
      8 ( 0.00%)  		qs1 = qs - (ez->reach_end? qs - qs0 : ez->max_q + 1);
      .           		mm_seq_rev(qs - qs0, qseq);
      .           	} else rs1 = rs, qs1 = qs;
      .           	re1 = rs, qe1 = qs;
      8 ( 0.00%)  	assert(qs1 >= 0 && rs1 >= 0);
      .           
  1,715 ( 0.00%)  	for (i = is_sr? cnt1 - 1 : 1; i < cnt1; ++i) { // gap filling
  1,723 ( 0.00%)  		if ((a[as1+i].y & (MM_SEED_IGNORE|MM_SEED_TANDEM)) && i != cnt1 - 1) continue;
  2,046 ( 0.00%)  		if (is_sr && !(mi->flag & MM_I_HPC)) {
      .           			re = (int32_t)a[as1 + i].x + 1;
      .           			qe = (int32_t)a[as1 + i].y + 1;
      .           		} else mm_adjust_minier(mi, qseq0, &a[as1 + i], &re, &qe);
      .           		re1 = re, qe1 = qe;
  4,693 ( 0.01%)  		if (i == cnt1 - 1 || (a[as1+i].y&MM_SEED_LONG_JOIN) || (qe - qs >= opt->min_ksw_len && re - rs >= opt->min_ksw_len)) {
  1,023 ( 0.00%)  			int j, bw1 = bw, zdrop_code;
    349 ( 0.00%)  			if (a[as1+i].y & MM_SEED_LONG_JOIN)
      .           				bw1 = qe - qs > re - rs? qe - qs : re - rs;
      .           			// perform alignment
    166 ( 0.00%)  			qseq = &qseq0[rev][qs];
    486 ( 0.00%)  			mm_idx_getseq(mi, rid, rs, re, tseq);
208,018 ( 0.33%)  => /home/kisliy/minimap2_v2.18/index.c:mm_idx_getseq (54x)
    324 ( 0.00%)  			mm_idx_bed_junc(mi, rid, rs, re, junc);
  4,168 ( 0.01%)  => /home/kisliy/minimap2_v2.18/index.c:mm_idx_bed_junc (54x)
    162 ( 0.00%)  			if (is_sr) { // perform ungapped alignment
      .           				assert(qe - qs == re - rs);
      .           				ksw_reset_extz(ez);
      .           				for (j = 0, ez->score = 0; j < qe - qs; ++j) {
      .           					if (qseq[j] >= 4 || tseq[j] >= 4) ez->score += opt->e2;
      .           					else ez->score += qseq[j] == tseq[j]? opt->a : -opt->b;
      .           				}
      .           				ez->cigar = ksw_push_cigar(km, &ez->n_cigar, &ez->m_cigar, ez->cigar, 0, qe - qs);
      .           			} else { // perform normal gapped alignment
  1,247 ( 0.00%)  				mm_align_pair(km, opt, qe - qs, qseq, re - rs, tseq, junc, mat, bw1, -1, opt->zdrop, extra_flag|KSW_EZ_APPROX_MAX, ez); // first pass: with approximate Z-drop
44,750,707 (71.33%)  => align.c:mm_align_pair (54x)
      .           			}
      .           			// test Z-drop and inversion Z-drop
    216 ( 0.00%)  			if ((zdrop_code = mm_test_zdrop(km, opt, qseq, tseq, ez->n_cigar, ez->cigar, mat)) != 0)
      .           				mm_align_pair(km, opt, qe - qs, qseq, re - rs, tseq, junc, mat, bw1, -1, zdrop_code == 2? opt->zdrop_inv : opt->zdrop, extra_flag, ez); // second pass: lift approximate
      .           			// update CIGAR
    378 ( 0.00%)  			if (ez->n_cigar > 0)
  3,862 ( 0.01%)  => align.c:mm_append_cigar.isra.4.part.5 (54x)
      .           				mm_append_cigar(r, ez->n_cigar, ez->cigar);
    162 ( 0.00%)  			if (ez->zdropped) { // truncated by Z-drop; TODO: sometimes Z-drop kicks in because the next seed placement is wrong. This can be fixed in principle.
      .           				if (!r->p) {
      .           					assert(ez->n_cigar == 0);
      .           					uint32_t capacity = sizeof(mm_extra_t)/4;
      .           					kroundup32(capacity);
      .           					r->p = (mm_extra_t*)calloc(capacity, 4);
      .           					r->p->capacity = capacity;
      .           				}
      .           				for (j = i - 1; j >= 0; --j)
-- line 749 ----------------------------------------
-- line 754 ----------------------------------------
      .           				r->p->dp_score += ez->max;
      .           				re1 = rs + (ez->max_t + 1);
      .           				qe1 = qs + (ez->max_q + 1);
      .           				if (cnt1 - (j + 1) >= opt->min_cnt) {
      .           					mm_split_reg(r, r2, as1 + j + 1 - r->as, qlen, a);
      .           					if (zdrop_code == 2) r2->split_inv = 1;
      .           				}
      .           				break;
    648 ( 0.00%)  			} else r->p->dp_score += ez->score;
      .           			rs = re, qs = qe;
      .           		}
      .           	}
      .           
      4 ( 0.00%)  	if (!dropped && qe < qe0 && re < re0) { // right extension
      4 ( 0.00%)  		qseq = &qseq0[rev][qe];
      8 ( 0.00%)  		mm_idx_getseq(mi, rid, re, re0, tseq);
    217 ( 0.00%)  => /home/kisliy/minimap2_v2.18/index.c:mm_idx_getseq (1x)
      6 ( 0.00%)  		mm_idx_bed_junc(mi, rid, re, re0, junc);
     43 ( 0.00%)  => /home/kisliy/minimap2_v2.18/index.c:mm_idx_bed_junc (1x)
     25 ( 0.00%)  		mm_align_pair(km, opt, qe0 - qe, qseq, re0 - re, tseq, junc, mat, bw, opt->end_bonus, opt->zdrop, extra_flag|KSW_EZ_EXTZ_ONLY, ez);
237,123 ( 0.38%)  => align.c:mm_align_pair (1x)
      8 ( 0.00%)  		if (ez->n_cigar > 0) {
     42 ( 0.00%)  => align.c:mm_append_cigar.isra.4.part.5 (1x)
      .           			mm_append_cigar(r, ez->n_cigar, ez->cigar);
      5 ( 0.00%)  			r->p->dp_score += ez->max;
      .           		}
      8 ( 0.00%)  		re1 = re + (ez->reach_end? ez->mqe_t + 1 : ez->max_t + 1);
      7 ( 0.00%)  		qe1 = qe + (ez->reach_end? qe0 - qe : ez->max_q + 1);
      .           	}
      3 ( 0.00%)  	assert(qe1 <= qlen);
      .           
      5 ( 0.00%)  	r->rs = rs1, r->re = re1;
      3 ( 0.00%)  	if (rev) r->qs = qlen - qe1, r->qe = qlen - qs1;
      6 ( 0.00%)  	else r->qs = qs1, r->qe = qe1;
      .           
      4 ( 0.00%)  	assert(re1 - rs1 <= re0 - rs0);
      3 ( 0.00%)  	if (r->p) {
      6 ( 0.00%)  		mm_idx_getseq(mi, rid, rs1, re1, tseq);
207,931 ( 0.33%)  => /home/kisliy/minimap2_v2.18/index.c:mm_idx_getseq (1x)
     16 ( 0.00%)  		mm_update_extra(r, &qseq0[r->rev][qs1], tseq, mat, opt->q, opt->e, opt->flag & MM_F_EQX);
399,830 ( 0.64%)  => align.c:mm_update_extra (1x)
      3 ( 0.00%)  		if (rev && r->p->trans_strand)
      .           			r->p->trans_strand ^= 3; // flip to the read strand
      .           	}
      .           
      4 ( 0.00%)  	kfree(km, tseq);
     58 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (1x)
      4 ( 0.00%)  	kfree(km, junc);
     55 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (1x)
      8 ( 0.00%)  }
      .           
      .           static int mm_align1_inv(void *km, const mm_mapopt_t *opt, const mm_idx_t *mi, int qlen, uint8_t *qseq0[2], const mm_reg1_t *r1, const mm_reg1_t *r2, mm_reg1_t *r_inv, ksw_extz_t *ez)
      .           {
      .           	int tl, ql, score, ret = 0, q_off, t_off;
      .           	uint8_t *tseq, *qseq;
      .           	int8_t mat[25];
      .           	void *qp;
      .           
-- line 803 ----------------------------------------
-- line 857 ----------------------------------------
      .           	if (i + 1 != *n_regs)
      .           		memmove(&regs[i + 2], &regs[i + 1], sizeof(mm_reg1_t) * (*n_regs - i - 1));
      .           	regs[i + 1] = *r;
      .           	++*n_regs;
      .           	return regs;
      .           }
      .           
      .           mm_reg1_t *mm_align_skeleton(void *km, const mm_mapopt_t *opt, const mm_idx_t *mi, int qlen, const char *qstr, int *n_regs_, mm_reg1_t *regs, mm128_t *a)
     15 ( 0.00%)  {
      .           	extern unsigned char seq_nt4_table[256];
      2 ( 0.00%)  	int32_t i, n_regs = *n_regs_, n_a;
      .           	uint8_t *qseq0[2];
      .           	ksw_extz_t ez;
      .           
      .           	// encode the query sequence
      4 ( 0.00%)  	qseq0[0] = (uint8_t*)kmalloc(km, qlen * 2);
     43 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
      3 ( 0.00%)  	qseq0[1] = qseq0[0] + qlen;
 33,002 ( 0.05%)  	for (i = 0; i < qlen; ++i) {
 49,497 ( 0.08%)  		qseq0[0][i] = seq_nt4_table[(uint8_t)qstr[i]];
214,491 ( 0.34%)  		qseq0[1][qlen - 1 - i] = qseq0[0][i] < 4? 3 - qseq0[0][i] : 4;
      .           	}
      .           
      .           	// align through seed hits
      7 ( 0.00%)  	n_a = mm_squeeze_a(km, n_regs, regs, a);
    147 ( 0.00%)  => /home/kisliy/minimap2_v2.18/hit.c:mm_squeeze_a (1x)
     11 ( 0.00%)  	memset(&ez, 0, sizeof(ksw_extz_t));
      5 ( 0.00%)  	for (i = 0; i < n_regs; ++i) {
      .           		mm_reg1_t r2;
      5 ( 0.00%)  		if ((opt->flag&MM_F_SPLICE) && (opt->flag&MM_F_SPLICE_FOR) && (opt->flag&MM_F_SPLICE_REV)) { // then do two rounds of alignments for both strands
      .           			mm_reg1_t s[2], s2[2];
      .           			int which, trans_strand;
      4 ( 0.00%)  			s[0] = s[1] = regs[i];
      .           			mm_align1(km, opt, mi, qlen, qseq0, &s[0], &s2[0], n_a, a, &ez, MM_F_SPLICE_FOR);
      6 ( 0.00%)  			mm_align1(km, opt, mi, qlen, qseq0, &s[1], &s2[1], n_a, a, &ez, MM_F_SPLICE_REV);
      .           			if (s[0].p->dp_score > s[1].p->dp_score) which = 0, trans_strand = 1;
      .           			else if (s[0].p->dp_score < s[1].p->dp_score) which = 1, trans_strand = 2;
      .           			else trans_strand = 3, which = (qlen + s[0].p->dp_score) & 1; // randomly choose a strand, effectively
      .           			if (which == 0) {
      .           				regs[i] = s[0], r2 = s2[0];
      .           				free(s[1].p);
      .           			} else {
      .           				regs[i] = s[1], r2 = s2[1];
      .           				free(s[0].p);
      .           			}
      .           			regs[i].p->trans_strand = trans_strand;
      .           		} else { // one round of alignment
     16 ( 0.00%)  			mm_align1(km, opt, mi, qlen, qseq0, &regs[i], &r2, n_a, a, &ez, opt->flag);
46,424,978 (74.00%)  => align.c:mm_align1 (1x)
      3 ( 0.00%)  			if (opt->flag&MM_F_SPLICE)
      .           				regs[i].p->trans_strand = opt->flag&MM_F_SPLICE_FOR? 1 : 2;
      .           		}
      4 ( 0.00%)  		if (r2.cnt > 0) regs = mm_insert_reg(&r2, i, &n_regs, regs);
      3 ( 0.00%)  		if (i > 0 && regs[i].split_inv) {
      .           			if (mm_align1_inv(km, opt, mi, qlen, qseq0, &regs[i-1], &regs[i], &r2, &ez)) {
      .           				regs = mm_insert_reg(&r2, i, &n_regs, regs);
      .           				++i; // skip the inserted INV alignment
      .           			}
      .           		}
      .           	}
      3 ( 0.00%)  	*n_regs_ = n_regs;
      4 ( 0.00%)  	kfree(km, qseq0[0]);
     34 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (1x)
      3 ( 0.00%)  	kfree(km, ez.cigar);
     53 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (1x)
      6 ( 0.00%)  	mm_filter_regs(opt, qlen, n_regs_, regs);
     58 ( 0.00%)  => /home/kisliy/minimap2_v2.18/hit.c:mm_filter_regs (1x)
      5 ( 0.00%)  	mm_hit_sort(km, n_regs_, regs, opt->alt_drop);
     22 ( 0.00%)  => /home/kisliy/minimap2_v2.18/hit.c:mm_hit_sort (1x)
      .           	return regs;
      9 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: kthread.c
--------------------------------------------------------------------------------
Ir               

-- line 47 ----------------------------------------
      .           		w->t->func(w->t->data, i, w - w->t->w);
      .           	}
      .           	while ((i = steal_work(w->t)) >= 0)
      .           		w->t->func(w->t->data, i, w - w->t->w);
      .           	pthread_exit(0);
      .           }
      .           
      .           void kt_for(int n_threads, void (*func)(void*,long,int), void *data, long n)
     22 ( 0.00%)  {
      4 ( 0.00%)  	if (n_threads > 1) {
      .           		int i;
      .           		kt_for_t t;
      .           		pthread_t *tid;
      .           		t.func = func, t.data = data, t.n_threads = n_threads, t.n = n;
      .           		t.w = (ktf_worker_t*)calloc(n_threads, sizeof(ktf_worker_t));
      .           		tid = (pthread_t*)calloc(n_threads, sizeof(pthread_t));
      .           		for (i = 0; i < n_threads; ++i)
      .           			t.w[i].t = &t, t.w[i].i = i;
      .           		for (i = 0; i < n_threads; ++i) pthread_create(&tid[i], 0, ktf_worker, &t.w[i]);
      .           		for (i = 0; i < n_threads; ++i) pthread_join(tid[i], 0);
      .           		free(tid); free(t.w);
      .           	} else {
      .           		long j;
114,703 ( 0.18%)  		for (j = 0; j < n; ++j) func(data, j, 0);
50,436,416 (80.40%)  => /home/kisliy/minimap2_v2.18/map.c:worker_for (1x)
4,661,969 ( 7.43%)  => /home/kisliy/minimap2_v2.18/index.c:worker_post (16,384x)
      .           	}
     16 ( 0.00%)  }
      .           
      .           /*****************
      .            * kt_pipeline() *
      .            *****************/
      .           
      .           struct ktp_t;
      .           
      .           typedef struct {
-- line 80 ----------------------------------------
-- line 90 ----------------------------------------
      .           	int64_t index;
      .           	int n_workers, n_steps;
      .           	ktp_worker_t *workers;
      .           	pthread_mutex_t mutex;
      .           	pthread_cond_t cv;
      .           } ktp_t;
      .           
      .           static void *ktp_worker(void *data)
     12 ( 0.00%)  {
      .           	ktp_worker_t *w = (ktp_worker_t*)data;
      2 ( 0.00%)  	ktp_t *p = w->pl;
     34 ( 0.00%)  	while (w->step < p->n_steps) {
      .           		// test whether we can kick off the job with this worker
     36 ( 0.00%)  		pthread_mutex_lock(&p->mutex);
  1,209 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
    192 ( 0.00%)  => ???:pthread_mutex_lock (8x)
      .           		for (;;) {
      .           			int i;
      .           			// test whether another worker is doing the same step
     80 ( 0.00%)  			for (i = 0; i < p->n_workers; ++i) {
     16 ( 0.00%)  				if (w == &p->workers[i]) continue; // ignore itself
      .           				if (p->workers[i].step <= w->step && p->workers[i].index < w->index)
      .           					break;
      .           			}
      .           			if (i == p->n_workers) break; // no workers with smaller indices are doing w->step or the previous steps
      .           			pthread_cond_wait(&p->cv, &p->mutex);
      .           		}
     28 ( 0.00%)  		pthread_mutex_unlock(&p->mutex);
  1,266 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
    136 ( 0.00%)  => ???:pthread_mutex_unlock (8x)
      .           
      .           		// working on w->step
     68 ( 0.00%)  		w->data = p->func(p->shared, w->step, w->step? w->data : 0); // for the first step, input is NULL
50,992,096 (81.28%)  => /home/kisliy/minimap2_v2.18/map.c:worker_pipeline (4x)
3,581,323 ( 5.71%)  => /home/kisliy/minimap2_v2.18/index.c:worker_pipeline (4x)
      .           
      .           		// update step and let other workers know
     24 ( 0.00%)  		pthread_mutex_lock(&p->mutex);
    192 ( 0.00%)  => ???:pthread_mutex_lock (8x)
     82 ( 0.00%)  		w->step = w->step == p->n_steps - 1 || w->data? (w->step + 1) % p->n_steps : p->n_steps;
     24 ( 0.00%)  		if (w->step == 0) w->index = p->index++;
     28 ( 0.00%)  		pthread_cond_broadcast(&p->cv);
  1,261 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
    104 ( 0.00%)  => ???:pthread_cond_broadcast@@GLIBC_2.3.2 (8x)
     24 ( 0.00%)  		pthread_mutex_unlock(&p->mutex);
    136 ( 0.00%)  => ???:pthread_mutex_unlock (8x)
      .           	}
     10 ( 0.00%)  	pthread_exit(0);
 90,093 ( 0.14%)  => ???:pthread_exit (2x)
  1,111 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
      .           }
      .           
      .           void kt_pipeline(int n_threads, void *(*func)(void*, int, void*), void *shared_data, int n_steps)
     16 ( 0.00%)  {
      .           	ktp_t aux;
      .           	pthread_t *tid;
      .           	int i;
      .           
      4 ( 0.00%)  	if (n_threads < 1) n_threads = 1;
      2 ( 0.00%)  	aux.n_workers = n_threads;
      2 ( 0.00%)  	aux.n_steps = n_steps;
      2 ( 0.00%)  	aux.func = func;
      2 ( 0.00%)  	aux.shared = shared_data;
      2 ( 0.00%)  	aux.index = 0;
     12 ( 0.00%)  	pthread_mutex_init(&aux.mutex, 0);
  1,195 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
     62 ( 0.00%)  => ???:pthread_mutex_init (2x)
     12 ( 0.00%)  	pthread_cond_init(&aux.cv, 0);
  1,395 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
     30 ( 0.00%)  => ???:pthread_cond_init@@GLIBC_2.3.2 (2x)
      .           
     20 ( 0.00%)  	aux.workers = (ktp_worker_t*)calloc(n_threads, sizeof(ktp_worker_t));
    462 ( 0.00%)  => ???:calloc (2x)
      6 ( 0.00%)  	for (i = 0; i < n_threads; ++i) {
      .           		ktp_worker_t *w = &aux.workers[i];
      6 ( 0.00%)  		w->step = 0; w->pl = &aux; w->data = 0;
     10 ( 0.00%)  		w->index = aux.index++;
      .           	}
      .           
     20 ( 0.00%)  	tid = (pthread_t*)calloc(n_threads, sizeof(pthread_t));
    452 ( 0.00%)  => ???:calloc (2x)
     30 ( 0.00%)  	for (i = 0; i < n_threads; ++i) pthread_create(&tid[i], 0, ktp_worker, &aux.workers[i]);
  1,135 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
  2,134 ( 0.00%)  => ???:pthread_create@@GLIBC_2.2.5 (2x)
     18 ( 0.00%)  	for (i = 0; i < n_threads; ++i) pthread_join(tid[i], 0);
  1,111 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
    290 ( 0.00%)  => ???:pthread_join (2x)
     12 ( 0.00%)  	free(tid); free(aux.workers);
    340 ( 0.00%)  => ???:free (4x)
      .           
     10 ( 0.00%)  	pthread_mutex_destroy(&aux.mutex);
  1,246 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
     20 ( 0.00%)  => ???:pthread_mutex_destroy (2x)
     10 ( 0.00%)  	pthread_cond_destroy(&aux.cv);
  1,467 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
     66 ( 0.00%)  => ???:pthread_cond_destroy@@GLIBC_2.3.2 (2x)
     14 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: chain.c
--------------------------------------------------------------------------------
Ir              

-- line 10 ----------------------------------------
     .           	-1, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
     .           	LT(4), LT(5), LT(5), LT(6), LT(6), LT(6), LT(6),
     .           	LT(7), LT(7), LT(7), LT(7), LT(7), LT(7), LT(7), LT(7)
     .           };
     .           
     .           static inline int ilog2_32(uint32_t v)
     .           {
     .           	uint32_t t, tt;
11,608 ( 0.02%)  	if ((tt = v>>16)) return (t = tt>>8) ? 24 + LogTable256[t] : 16 + LogTable256[tt];
20,315 ( 0.03%)  	return (t = v>>8) ? 8 + LogTable256[t] : LogTable256[v];
     .           }
     .           
     .           mm128_t *mm_chain_dp(int max_dist_x, int max_dist_y, int bw, int max_skip, int max_iter, int min_cnt, int min_sc, float gap_scale, int is_cdna, int n_segs, int64_t n, mm128_t *a, int *n_u_, uint64_t **_u, void *km)
    14 ( 0.00%)  { // TODO: make sure this works when n has more than 32 bits
     .           	int32_t k, *f, *p, *t, *v, n_u, n_v;
     2 ( 0.00%)  	int64_t i, j, st = 0;
     3 ( 0.00%)  	uint64_t *u, *u2, sum_qspan = 0;
     .           	float avg_qspan;
     .           	mm128_t *b, *w;
     .           
     6 ( 0.00%)  	if (_u) *_u = 0, *n_u_ = 0;
     4 ( 0.00%)  	if (n == 0 || a == 0) {
     .           		kfree(km, a);
     .           		return 0;
     .           	}
     9 ( 0.00%)  	f = (int32_t*)kmalloc(km, n * 4);
    34 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
     4 ( 0.00%)  	p = (int32_t*)kmalloc(km, n * 4);
    34 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
     4 ( 0.00%)  	t = (int32_t*)kmalloc(km, n * 4);
    34 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
     4 ( 0.00%)  	v = (int32_t*)kmalloc(km, n * 4);
    34 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
     6 ( 0.00%)  	memset(t, 0, n * 4);
   163 ( 0.00%)  => ???:__GI_memset (1x)
     .           
 1,735 ( 0.00%)  	for (i = 0; i < n; ++i) sum_qspan += a[i].y>>32&0xff;
     5 ( 0.00%)  	avg_qspan = (float)sum_qspan / n;
     .           
     .           	// fill the score and backtrack arrays
 1,041 ( 0.00%)  	for (i = 0; i < n; ++i) {
 1,038 ( 0.00%)  		uint64_t ri = a[i].x;
   345 ( 0.00%)  		int64_t max_j = -1;
 2,076 ( 0.00%)  		int32_t qi = (int32_t)a[i].y, q_span = a[i].y>>32&0xff; // NB: only 8 bits of span is used!!!
   345 ( 0.00%)  		int32_t max_f = q_span, n_skip = 0, min_d;
   695 ( 0.00%)  		int32_t sidi = (a[i].y & MM_SEED_SEG_MASK) >> MM_SEED_SEG_SHIFT;
 6,046 ( 0.01%)  		while (st < i && ri > a[st].x + max_dist_x) ++st;
 2,422 ( 0.00%)  		if (i - st > max_iter) st = i - max_iter;
36,692 ( 0.06%)  		for (j = i - 1; j >= st; --j) {
     .           			int64_t dr = ri - a[j].x;
35,880 ( 0.06%)  			int32_t dq = qi - (int32_t)a[j].y, dd, sc, log_dd, gap_cost;
27,945 ( 0.04%)  			int32_t sidj = (a[j].y & MM_SEED_SEG_MASK) >> MM_SEED_SEG_SHIFT;
98,670 ( 0.16%)  			if ((sidi == sidj && dr == 0) || dq <= 0) continue; // don't skip if an anchor is used by multiple segments; see below
53,172 ( 0.08%)  			if ((sidi == sidj && dq > max_dist_y) || dq > max_dist_x) continue;
53,172 ( 0.08%)  			dd = dr > dq? dr - dq : dq - dr;
17,724 ( 0.03%)  			if (sidi == sidj && dd > bw) continue;
27,620 ( 0.04%)  			if (n_segs > 1 && !is_cdna && sidi == sidj && dr > max_dist_y) continue;
53,172 ( 0.08%)  			min_d = dq < dr? dq : dr;
     .           			sc = min_d > q_span? q_span : dq < dr? dq : dr;
26,586 ( 0.04%)  			log_dd = dd? ilog2_32(dd) : 0;
     .           			gap_cost = 0;
53,172 ( 0.08%)  			if (is_cdna || sidi != sidj) {
     .           				int c_log, c_lin;
     3 ( 0.00%)  				c_lin = (int)(dd * .01 * avg_qspan);
     .           				c_log = log_dd;
     .           				if (sidi != sidj && dr == 0) ++sc; // possibly due to overlapping paired ends; give a minor bonus
     .           				else if (dr > dq || sidi != sidj) gap_cost = c_lin < c_log? c_lin : c_log;
     .           				else gap_cost = c_lin + (c_log>>1);
88,968 ( 0.14%)  			} else gap_cost = (int)(dd * .01 * avg_qspan) + (log_dd>>1);
62,035 ( 0.10%)  			sc -= (int)((double)gap_cost * gap_scale + .499);
17,724 ( 0.03%)  			sc += f[j];
17,724 ( 0.03%)  			if (sc > max_f) {
     .           				max_f = sc, max_j = j;
 1,032 ( 0.00%)  				if (n_skip > 0) --n_skip;
34,072 ( 0.05%)  			} else if (t[j] == i) {
34,387 ( 0.05%)  				if (++n_skip > max_skip)
     .           					break;
     .           			}
68,260 ( 0.11%)  			if (p[j] >= 0) t[p[j]] = i;
     .           		}
 3,111 ( 0.00%)  		f[i] = max_f, p[i] = max_j;
 2,418 ( 0.00%)  		v[i] = max_j >= 0 && v[max_j] > max_f? v[max_j] : max_f; // v[] keeps the peak score up to i; f[] is the score ending at i, not always the peak
     .           	}
     .           
     .           	// find the ending positions of chains
    14 ( 0.00%)  	memset(t, 0, n * 4);
   163 ( 0.00%)  => ???:__GI_memset (1x)
   698 ( 0.00%)  	for (i = 0; i < n; ++i)
 1,728 ( 0.00%)  		if (p[i] >= 0) t[p[i]] = 1;
 1,038 ( 0.00%)  	for (i = n_u = 0; i < n; ++i)
 1,038 ( 0.00%)  		if (t[i] == 0 && v[i] >= min_sc)
     8 ( 0.00%)  			++n_u;
     2 ( 0.00%)  	if (n_u == 0) {
     .           		kfree(km, a); kfree(km, f); kfree(km, p); kfree(km, t); kfree(km, v);
     .           		return 0;
     .           	}
     6 ( 0.00%)  	u = (uint64_t*)kmalloc(km, n_u * 8);
    34 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
 1,047 ( 0.00%)  	for (i = n_u = 0; i < n; ++i) {
 1,390 ( 0.00%)  		if (t[i] == 0 && v[i] >= min_sc) {
     .           			j = i;
     5 ( 0.00%)  			while (j >= 0 && f[j] < v[j]) j = p[j]; // find the peak that maximizes f[]
     .           			if (j < 0) j = i; // TODO: this should really be assert(j>=0)
     6 ( 0.00%)  			u[n_u++] = (uint64_t)f[j] << 32 | j;
     .           		}
     .           	}
     6 ( 0.00%)  	radix_sort_64(u, u + n_u);
     9 ( 0.00%)  => /home/kisliy/minimap2_v2.18/misc.c:radix_sort_64 (1x)
     5 ( 0.00%)  	for (i = 0; i < n_u>>1; ++i) { // reverse, s.t. the highest scoring chain is the first
     .           		uint64_t t = u[i];
     .           		u[i] = u[n_u - i - 1], u[n_u - i - 1] = t;
     .           	}
     .           
     .           	// backtrack
     6 ( 0.00%)  	memset(t, 0, n * 4);
   163 ( 0.00%)  => ???:__GI_memset (1x)
    11 ( 0.00%)  	for (i = n_v = k = 0; i < n_u; ++i) { // starting from the highest score
     .           		int32_t n_v0 = n_v, k0 = k;
   346 ( 0.00%)  		j = (int32_t)u[i];
     .           		do {
   684 ( 0.00%)  			v[n_v++] = j;
   342 ( 0.00%)  			t[j] = 1;
   342 ( 0.00%)  			j = p[j];
 1,707 ( 0.00%)  		} while (j >= 0 && t[j] == 0);
     .           		if (j < 0) {
    17 ( 0.00%)  			if (n_v - n_v0 >= min_cnt) u[k++] = u[i]>>32<<32 | (n_v - n_v0);
     .           		} else if ((int32_t)(u[i]>>32) - f[j] >= min_sc) {
     .           			if (n_v - n_v0 >= min_cnt) u[k++] = ((u[i]>>32) - f[j]) << 32 | (n_v - n_v0);
     .           		}
     7 ( 0.00%)  		if (k0 == k) n_v = n_v0; // no new chain added, reset
     .           	}
     6 ( 0.00%)  	*n_u_ = n_u = k, *_u = u; // NB: note that u[] may not be sorted by score here
     .           
     .           	// free temporary arrays
    13 ( 0.00%)  	kfree(km, f); kfree(km, p); kfree(km, t);
   172 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (3x)
     .           
     .           	// write the result to b[]
     5 ( 0.00%)  	b = (mm128_t*)kmalloc(km, n_v * sizeof(mm128_t));
    36 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
    12 ( 0.00%)  	for (i = 0, k = 0; i < n_u; ++i) {
     .           		int32_t k0 = k, ni = (int32_t)u[i];
   701 ( 0.00%)  		for (j = 0; j < ni; ++j)
 2,736 ( 0.00%)  			b[k] = a[v[k0 + (ni - j - 1)]], ++k;
     .           	}
     3 ( 0.00%)  	kfree(km, v);
    60 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (1x)
     .           
     .           	// sort u[] and a[] by a[].x, such that adjacent chains may be joined (required by mm_join_long)
     8 ( 0.00%)  	w = (mm128_t*)kmalloc(km, n_u * sizeof(mm128_t));
    36 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
     6 ( 0.00%)  	for (i = k = 0; i < n_u; ++i) {
     9 ( 0.00%)  		w[i].x = b[k].x, w[i].y = (uint64_t)k<<32|i;
     1 ( 0.00%)  		k += (int32_t)u[i];
     .           	}
     5 ( 0.00%)  	radix_sort_128x(w, w + n_u);
     9 ( 0.00%)  => /home/kisliy/minimap2_v2.18/misc.c:radix_sort_128x (1x)
    14 ( 0.00%)  	u2 = (uint64_t*)kmalloc(km, n_u * 8);
    34 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
     4 ( 0.00%)  	for (i = k = 0; i < n_u; ++i) {
     2 ( 0.00%)  		int32_t j = (int32_t)w[i].y, n = (int32_t)u[j];
     2 ( 0.00%)  		u2[i] = u[j];
    11 ( 0.00%)  		memcpy(&a[k], &b[w[i].y>>32], n * sizeof(mm128_t));
   883 ( 0.00%)  => ???:__memcpy_ssse3_back (1x)
     2 ( 0.00%)  		k += n;
     .           	}
     9 ( 0.00%)  	if (n_u) memcpy(u, u2, n_u * 8);
    14 ( 0.00%)  => ???:__memcpy_ssse3_back (1x)
     9 ( 0.00%)  	if (k) memcpy(b, a, k * sizeof(mm128_t)); // write _a_ to _b_ and deallocate _a_ because _a_ is oversized, sometimes a lot
   884 ( 0.00%)  => ???:__memcpy_ssse3_back (1x)
     9 ( 0.00%)  	kfree(km, a); kfree(km, w); kfree(km, u2);
   173 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (3x)
     1 ( 0.00%)  	return b;
     8 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: sketch.c
--------------------------------------------------------------------------------
Ir               

-- line 22 ----------------------------------------
      .           	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
      .           	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
      .           	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
      .           	4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4
      .           };
      .           
      .           static inline uint64_t hash64(uint64_t key, uint64_t mask)
      .           {
198,240 ( 0.32%)  	key = (~key + (key << 21)) & mask; // key = (key << 21) - key - 1;
 99,120 ( 0.16%)  	key = key ^ key >> 24;
165,200 ( 0.26%)  	key = ((key + (key << 3)) + (key << 8)) & mask; // key * 265
 99,120 ( 0.16%)  	key = key ^ key >> 14;
165,200 ( 0.26%)  	key = ((key + (key << 2)) + (key << 4)) & mask; // key * 21
 99,120 ( 0.16%)  	key = key ^ key >> 28;
132,160 ( 0.21%)  	key = (key + (key << 31)) & mask;
      .           	return key;
      .           }
      .           
      .           typedef struct { // a simplified version of kdq
      .           	int front, count;
      .           	int a[32];
      .           } tiny_queue_t;
      .           
-- line 44 ----------------------------------------
-- line 70 ----------------------------------------
      .            * @param p      minimizers
      .            *               p->a[i].x = kMer<<8 | kmerSpan
      .            *               p->a[i].y = rid<<32 | lastPos<<1 | strand
      .            *               where lastPos is the position of the last base of the i-th minimizer,
      .            *               and strand indicates whether the minimizer comes from the top or the bottom strand.
      .            *               Callers may want to set "p->n = 0"; otherwise results are appended to p
      .            */
      .           void mm_sketch(void *km, const char *str, int len, int w, int k, uint32_t rid, int is_hpc, mm128_v *p)
     28 ( 0.00%)  {
     20 ( 0.00%)  	uint64_t shift1 = 2 * (k - 1), mask = (1ULL<<2*k) - 1, kmer[2] = {0,0};
      .           	int i, j, l, buf_pos, min_pos, kmer_span = 0;
      .           	mm128_t buf[256], min = { UINT64_MAX, UINT64_MAX };
      .           	tiny_queue_t tq;
      .           
     14 ( 0.00%)  	assert(len > 0 && (w > 0 && w < 256) && (k > 0 && k <= 28)); // 56 bits for k-mer; could use long k-mers, but 28 enough in practice
     18 ( 0.00%)  	memset(buf, 0xff, w * 16);
     60 ( 0.00%)  => ???:__GI_memset (2x)
     44 ( 0.00%)  	memset(&tq, 0, sizeof(tiny_queue_t));
     66 ( 0.00%)  	kv_resize(mm128_t, km, *p, p->n + len/w);
    800 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:krealloc (2x)
      .           
165,336 ( 0.26%)  	for (i = l = buf_pos = min_pos = 0; i < len; ++i) {
165,340 ( 0.26%)  		int c = seq_nt4_table[(uint8_t)str[i]];
    112 ( 0.00%)  		mm128_t info = { UINT64_MAX, UINT64_MAX };
 66,136 ( 0.11%)  		if (c < 4) { // not an ambiguous base
      .           			int z;
 99,204 ( 0.16%)  			if (is_hpc) {
      .           				int skip_len = 1;
      .           				if (i + 1 < len && seq_nt4_table[(uint8_t)str[i + 1]] == c) {
      .           					for (skip_len = 2; i + skip_len < len; ++skip_len)
      .           						if (seq_nt4_table[(uint8_t)str[i + skip_len]] != c)
      .           							break;
      .           					i += skip_len - 1; // put $i at the end of the current homopolymer run
      .           				}
      .           				tq_push(&tq, skip_len);
      .           				kmer_span += skip_len;
      .           				if (tq.count > k) kmer_span -= tq_shift(&tq);
297,612 ( 0.47%)  			} else kmer_span = l + 1 < k? l + 1 : k;
198,408 ( 0.32%)  			kmer[0] = (kmer[0] << 2 | c) & mask;           // forward k-mer
264,544 ( 0.42%)  			kmer[1] = (kmer[1] >> 2) | (3ULL^c) << shift1; // reverse k-mer
 66,136 ( 0.11%)  			if (kmer[0] == kmer[1]) continue; // skip "symmetric k-mers" as we don't know it strand
 66,080 ( 0.11%)  			z = kmer[0] < kmer[1]? 0 : 1; // strand
 33,068 ( 0.05%)  			++l;
165,340 ( 0.26%)  			if (l >= k && kmer_span < 256) {
231,280 ( 0.37%)  				info.x = hash64(kmer[z], mask) << 8 | kmer_span;
198,260 ( 0.32%)  				info.y = (uint64_t)rid<<32 | (uint32_t)i<<1 | z;
      .           			}
      .           		} else l = 0, tq.count = tq.front = 0, kmer_span = 0;
297,612 ( 0.47%)  		buf[buf_pos] = info; // need to do this here as appropriate buf_pos and buf[buf_pos] are needed below
165,360 ( 0.26%)  		if (l == w + k - 1 && min.x != UINT64_MAX) { // special case for the first window - because identical k-mers are not stored yet
     78 ( 0.00%)  			for (j = buf_pos + 1; j < w; ++j)
    194 ( 0.00%)  				if (min.x == buf[j].x && buf[j].y != min.y) kv_push(mm128_t, km, *p, buf[j]);
     74 ( 0.00%)  			for (j = 0; j < buf_pos; ++j)
     14 ( 0.00%)  				if (min.x == buf[j].x && buf[j].y != min.y) kv_push(mm128_t, km, *p, buf[j]);
      .           		}
 66,136 ( 0.11%)  		if (info.x <= min.x) { // a new minimum; then write the old min
 61,414 ( 0.10%)  			if (l >= w + k && min.x != UINT64_MAX) kv_push(mm128_t, km, *p, min);
  6,292 ( 0.01%)  => /home/kisliy/minimap2_v2.18/kalloc.c:krealloc (1x)
      .           			min = info, min_pos = buf_pos;
 59,940 ( 0.10%)  		} else if (buf_pos == min_pos) { // old min has moved outside the window
 47,250 ( 0.08%)  			if (l >= w + k - 1 && min.x != UINT64_MAX) kv_push(mm128_t, km, *p, min);
    472 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:krealloc (1x)
 86,913 ( 0.14%)  			for (j = buf_pos + 1, min.x = UINT64_MAX; j < w; ++j) // the two loops are necessary when there are identical k-mers
 74,269 ( 0.12%)  				if (min.x >= buf[j].x) min = buf[j], min_pos = j; // >= is important s.t. min is always the closest k-mer
 84,737 ( 0.14%)  			for (j = 0; j <= buf_pos; ++j)
 60,558 ( 0.10%)  				if (min.x >= buf[j].x) min = buf[j], min_pos = j;
 12,596 ( 0.02%)  			if (l >= w + k - 1 && min.x != UINT64_MAX) { // write identical k-mers
 97,304 ( 0.16%)  				for (j = buf_pos + 1; j < w; ++j) // these two loops make sure the output is sorted
 74,216 ( 0.12%)  					if (min.x == buf[j].x && min.y != buf[j].y) kv_push(mm128_t, km, *p, buf[j]);
135,121 ( 0.22%)  				for (j = 0; j <= buf_pos; ++j)
 37,788 ( 0.06%)  					if (min.x == buf[j].x && min.y != buf[j].y) kv_push(mm128_t, km, *p, buf[j]);
      .           			}
      .           		}
 99,755 ( 0.16%)  		if (++buf_pos == w) buf_pos = 0;
      .           	}
      6 ( 0.00%)  	if (min.x != UINT64_MAX)
     22 ( 0.00%)  		kv_push(mm128_t, km, *p, min);
     16 ( 0.00%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: index.c
--------------------------------------------------------------------------------
Ir               

-- line 12 ----------------------------------------
      .           #include "bseq.h"
      .           #include "minimap.h"
      .           #include "mmpriv.h"
      .           #include "kvec.h"
      .           #include "khash.h"
      .           
      .           #define idx_hash(a) ((a)>>1)
      .           #define idx_eq(a, b) ((a)>>1 == (b)>>1)
405,419 ( 0.65%)  KHASH_INIT(idx, uint64_t, uint64_t, 1, idx_hash, idx_eq)
1,110,928 ( 1.77%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (11,336x)
      .           typedef khash_t(idx) idxhash_t;
      .           
      .           KHASH_MAP_INIT_STR(str, uint32_t)
      .           
      .           #define kroundup64(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, (x)|=(x)>>32, ++(x))
      .           
      .           typedef struct mm_idx_bucket_s {
      .           	mm128_v a;   // (minimizer, position) array
-- line 28 ----------------------------------------
-- line 37 ----------------------------------------
      .           } mm_idx_intv1_t;
      .           
      .           typedef struct mm_idx_intv_s {
      .           	int32_t n, m;
      .           	mm_idx_intv1_t *a;
      .           } mm_idx_intv_t;
      .           
      .           mm_idx_t *mm_idx_init(int w, int k, int b, int flag)
     12 ( 0.00%)  {
      .           	mm_idx_t *mi;
      1 ( 0.00%)  	if (k*2 < b) b = k * 2;
      3 ( 0.00%)  	if (w < 1) w = 1;
      5 ( 0.00%)  	mi = (mm_idx_t*)calloc(1, sizeof(mm_idx_t));
    246 ( 0.00%)  => ???:calloc (1x)
      4 ( 0.00%)  	mi->w = w, mi->k = k, mi->b = b, mi->flag = flag;
      7 ( 0.00%)  	mi->B = (mm_idx_bucket_t*)calloc(1<<b, sizeof(mm_idx_bucket_t));
    296 ( 0.00%)  => ???:calloc (1x)
      4 ( 0.00%)  	if (!(mm_dbg_flag & 1)) mi->km = km_init();
    243 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:km_init (1x)
      .           	return mi;
      9 ( 0.00%)  }
      .           
      .           void mm_idx_destroy(mm_idx_t *mi)
      6 ( 0.00%)  {
      .           	uint32_t i;
      2 ( 0.00%)  	if (mi == 0) return;
      3 ( 0.00%)  	if (mi->h) kh_destroy(str, (khash_t(str)*)mi->h);
      3 ( 0.00%)  	if (mi->B) {
114,695 ( 0.18%)  		for (i = 0; i < 1U<<mi->b; ++i) {
 98,304 ( 0.16%)  			free(mi->B[i].p);
347,076 ( 0.55%)  => ???:free (16,384x)
 65,536 ( 0.10%)  			free(mi->B[i].a.a);
114,688 ( 0.18%)  => ???:free (16,384x)
 32,768 ( 0.05%)  			kh_destroy(idx, (idxhash_t*)mi->B[i].h);
      .           		}
      .           	}
      3 ( 0.00%)  	if (mi->I) {
      .           		for (i = 0; i < mi->n_seq; ++i)
      .           			free(mi->I[i].a);
      .           		free(mi->I);
      .           	}
      3 ( 0.00%)  	if (!mi->km) {
      .           		for (i = 0; i < mi->n_seq; ++i)
      .           			free(mi->seq[i].name);
      .           		free(mi->seq);
      1 ( 0.00%)  	} else km_destroy(mi->km);
    170 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:km_destroy (1x)
      9 ( 0.00%)  	free(mi->B); free(mi->S); free(mi);
    236 ( 0.00%)  => ???:free (3x)
      5 ( 0.00%)  }
      .           
      .           const uint64_t *mm_idx_get(const mm_idx_t *mi, uint64_t minier, int *n)
 12,420 ( 0.02%)  {
 12,420 ( 0.02%)  	int mask = (1<<mi->b) - 1;
      .           	khint_t k;
 15,525 ( 0.02%)  	mm_idx_bucket_t *b = &mi->B[minier&mask];
  3,105 ( 0.00%)  	idxhash_t *h = (idxhash_t*)b->h;
  3,105 ( 0.00%)  	*n = 0;
 10,098 ( 0.02%)  	if (h == 0) return 0;
  3,132 ( 0.00%)  	k = kh_get(idx, h, minier>>mi->b<<1);
    692 ( 0.00%)  	if (k == kh_end(h)) return 0;
  1,384 ( 0.00%)  	if (kh_key(h, k)&1) { // special casing when there is only one k-mer
    346 ( 0.00%)  		*n = 1;
    346 ( 0.00%)  		return &kh_val(h, k);
      .           	} else {
      .           		*n = (uint32_t)kh_val(h, k);
      .           		return &b->p[kh_val(h, k)>>32];
      .           	}
 15,525 ( 0.02%)  }
      .           
      .           void mm_idx_stat(const mm_idx_t *mi)
      6 ( 0.00%)  {
      .           	int n = 0, n1 = 0;
      .           	uint32_t i;
      5 ( 0.00%)  	uint64_t sum = 0, len = 0;
     12 ( 0.00%)  	fprintf(stderr, "[M::%s] kmer size: %d; skip: %d; is_hpc: %d; #seq: %d\n", __func__, mi->k, mi->w, mi->flag&MM_I_HPC, mi->n_seq);
  2,671 ( 0.00%)  => ???:fprintf (1x)
     11 ( 0.00%)  	for (i = 0; i < mi->n_seq; ++i)
      2 ( 0.00%)  		len += mi->seq[i].len;
 32,784 ( 0.05%)  	for (i = 0; i < 1U<<mi->b; ++i)
 68,370 ( 0.11%)  		if (mi->B[i].h) n += kh_size((idxhash_t*)mi->B[i].h);
 32,774 ( 0.05%)  	for (i = 0; i < 1U<<mi->b; ++i) {
 16,384 ( 0.03%)  		idxhash_t *h = (idxhash_t*)mi->B[i].h;
      .           		khint_t k;
 32,768 ( 0.05%)  		if (h == 0) continue;
 56,821 ( 0.09%)  		for (k = 0; k < kh_end(h); ++k)
102,024 ( 0.16%)  			if (kh_exist(h, k)) {
 23,780 ( 0.04%)  				sum += kh_key(h, k)&1? 1 : (uint32_t)kh_val(h, k);
  3,111 ( 0.00%)  				if (kh_key(h, k)&1) ++n1;
      .           			}
      .           	}
     22 ( 0.00%)  	fprintf(stderr, "[M::%s::%.3f*%.2f] distinct minimizers: %d (%.2f%% are singletons); average occurrences: %.3lf; average spacing: %.3lf; total length: %ld\n",
  9,066 ( 0.01%)  => ???:fprintf (1x)
      5 ( 0.00%)  			__func__, realtime() - mm_realtime0, cputime() / (realtime() - mm_realtime0), n, 100.0*n1/n, (double)sum / n, (double)len / sum, (long)len);
     28 ( 0.00%)  => /home/kisliy/minimap2_v2.18/misc.c:realtime (2x)
     20 ( 0.00%)  => /home/kisliy/minimap2_v2.18/misc.c:cputime (1x)
      5 ( 0.00%)  }
      .           
      .           int mm_idx_index_name(mm_idx_t *mi)
      .           {
      .           	khash_t(str) *h;
      .           	uint32_t i;
      .           	int has_dup = 0, absent;
      .           	if (mi->h) return 0;
      .           	h = kh_init(str);
-- line 130 ----------------------------------------
-- line 147 ----------------------------------------
      .           	if (h == 0) return -2;
      .           	k = kh_get(str, h, name);
      .           	return k == kh_end(h)? -1 : kh_val(h, k);
      .           }
      .           
      .           int mm_idx_getseq(const mm_idx_t *mi, uint32_t rid, uint32_t st, uint32_t en, uint8_t *seq)
      .           {
      .           	uint64_t i, st1, en1;
    627 ( 0.00%)  	if (rid >= mi->n_seq || st >= mi->seq[rid].len) return -1;
      .           	if (en > mi->seq[rid].len) en = mi->seq[rid].len;
    114 ( 0.00%)  	st1 = mi->seq[rid].offset + st;
    171 ( 0.00%)  	en1 = mi->seq[rid].offset + en;
 96,384 ( 0.15%)  	for (i = st1; i < en1; ++i)
320,520 ( 0.51%)  		seq[i - st1] = mm_seq4_get(mi->S, i);
    114 ( 0.00%)  	return en - st;
      .           }
      .           
      .           int32_t mm_idx_cal_max_occ(const mm_idx_t *mi, float f)
      5 ( 0.00%)  {
      .           	int i;
      .           	size_t n = 0;
      .           	uint32_t thres;
      .           	khint_t *a, k;
      4 ( 0.00%)  	if (f <= 0.) return INT32_MAX;
 65,550 ( 0.10%)  	for (i = 0; i < 1<<mi->b; ++i)
 54,820 ( 0.09%)  		if (mi->B[i].h) n += kh_size((idxhash_t*)mi->B[i].h);
      4 ( 0.00%)  	a = (uint32_t*)malloc(n * 4);
    181 ( 0.00%)  => ???:malloc (1x)
114,694 ( 0.18%)  	for (i = n = 0; i < 1<<mi->b; ++i) {
 16,384 ( 0.03%)  		idxhash_t *h = (idxhash_t*)mi->B[i].h;
 32,768 ( 0.05%)  		if (h == 0) continue;
 51,012 ( 0.08%)  		for (k = 0; k < kh_end(h); ++k) {
102,024 ( 0.16%)  			if (!kh_exist(h, k)) continue;
 27,999 ( 0.04%)  			a[n++] = kh_key(h, k)&1? 1 : (uint32_t)kh_val(h, k);
      .           		}
      .           	}
     12 ( 0.00%)  	thres = ks_ksmall_uint32_t(n, a, (uint32_t)((1. - f) * n)) + 1;
 46,798 ( 0.07%)  => /home/kisliy/minimap2_v2.18/misc.c:ks_ksmall_uint32_t (1x)
      3 ( 0.00%)  	free(a);
    115 ( 0.00%)  => ???:free (1x)
      .           	return thres;
      5 ( 0.00%)  }
      .           
      .           /*********************************
      .            * Sort and generate hash tables *
      .            *********************************/
      .           
      .           static void worker_post(void *g, long i, int tid)
131,072 ( 0.21%)  {
      .           	int n, n_keys;
      .           	size_t j, start_a, start_p;
      .           	idxhash_t *h;
      .           	mm_idx_t *mi = (mm_idx_t*)g;
 81,920 ( 0.13%)  	mm_idx_bucket_t *b = &mi->B[i];
 65,536 ( 0.10%)  	if (b->a.n == 0) return;
      .           
      .           	// sort by minimizer
 14,170 ( 0.02%)  	radix_sort_128x(b->a.a, b->a.a + b->a.n);
 32,117 ( 0.05%)  => /home/kisliy/minimap2_v2.18/misc.c:radix_sort_128x (2,834x)
      .           
      .           	// count and preallocate
 43,618 ( 0.07%)  	for (j = 1, n = 1, n_keys = 0, b->n = 0; j <= b->a.n; ++j) {
  8,715 ( 0.01%)  		if (j == b->a.n || b->a.a[j].x>>8 != b->a.a[j-1].x>>8) {
  3,111 ( 0.00%)  			++n_keys;
  6,222 ( 0.01%)  			if (n > 1) b->n += n;
      .           			n = 1;
      .           		} else ++n;
      .           	}
      .           	h = kh_init(idx);
      .           	kh_resize(idx, h, n_keys);
 19,838 ( 0.03%)  	b->p = (uint64_t*)calloc(b->n, 8);
643,318 ( 1.03%)  => ???:calloc (2,834x)
      .           
      .           	// create the hash table
 46,452 ( 0.07%)  	for (j = 1, n = 1, start_a = start_p = 0; j <= b->a.n; ++j) {
  9,823 ( 0.02%)  		if (j == b->a.n || b->a.a[j].x>>8 != b->a.a[j-1].x>>8) {
      .           			khint_t itr;
      .           			int absent;
      .           			mm128_t *p = &b->a.a[j-1];
 15,555 ( 0.02%)  			itr = kh_put(idx, h, p->x>>8>>mi->b<<1, &absent);
 35,393 ( 0.06%)  			assert(absent && j == start_a + n);
  6,222 ( 0.01%)  			if (n == 1) {
  6,222 ( 0.01%)  				kh_key(h, itr) |= 1;
 27,999 ( 0.04%)  				kh_val(h, itr) = p->y;
      .           			} else {
      .           				int k;
      .           				for (k = 0; k < n; ++k)
      .           					b->p[start_p + k] = b->a.a[start_a + k].y;
      .           				radix_sort_64(&b->p[start_p], &b->p[start_p + n]); // sort by position; needed as in-place radix_sort_128x() is not stable
      .           				kh_val(h, itr) = (uint64_t)start_p<<32 | n;
      .           				start_p += n;
      .           			}
      .           			start_a = j, n = 1;
      .           		} else ++n;
      .           	}
  5,668 ( 0.01%)  	b->h = h;
  5,668 ( 0.01%)  	assert(b->n == (int32_t)start_p);
      .           
      .           	// deallocate and clear b->a
 11,336 ( 0.02%)  	kfree(0, b->a.a);
286,222 ( 0.46%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (2,834x)
  8,502 ( 0.01%)  	b->a.n = b->a.m = 0, b->a.a = 0;
131,072 ( 0.21%)  }
      .            
      .           static void mm_idx_post(mm_idx_t *mi, int n_threads)
      .           {
      7 ( 0.00%)  	kt_for(n_threads, worker_post, mi, 1<<mi->b);
4,776,682 ( 7.61%)  => /home/kisliy/minimap2_v2.18/kthread.c:kt_for (1x)
      .           }
      .           
      .           /******************
      .            * Generate index *
      .            ******************/
      .           
      .           #include <string.h>
      .           #include <zlib.h>
-- line 255 ----------------------------------------
-- line 263 ----------------------------------------
      .           } pipeline_t;
      .           
      .           typedef struct {
      .               int n_seq;
      .           	mm_bseq1_t *seq;
      .           	mm128_v a;
      .           } step_t;
      .           
      6 ( 0.00%)  static void mm_idx_add(mm_idx_t *mi, int n, const mm128_t *a)
      .           {
      4 ( 0.00%)  	int i, mask = (1<<mi->b) - 1;
  6,491 ( 0.01%)  	for (i = 0; i < n; ++i) {
 18,666 ( 0.03%)  		mm128_v *p = &mi->B[a[i].x>>8&mask].a;
 68,405 ( 0.11%)  		kv_push(mm128_t, 0, *p, a[i]);
686,447 ( 1.09%)  => /home/kisliy/minimap2_v2.18/kalloc.c:krealloc (2,850x)
      .           	}
      6 ( 0.00%)  }
      .           
      .           static void *worker_pipeline(void *shared, int step, void *in)
     32 ( 0.00%)  {
      .           	int i;
      .               pipeline_t *p = (pipeline_t*)shared;
      8 ( 0.00%)      if (step == 0) { // step 0: read sequences
      .                   step_t *s;
      7 ( 0.00%)  		if (p->sum_len > p->batch_size) return 0;
     10 ( 0.00%)          s = (step_t*)calloc(1, sizeof(step_t));
  1,224 ( 0.00%)  => ???:calloc (2x)
     12 ( 0.00%)  		s->seq = mm_bseq_read(p->fp, p->mini_batch_size, 0, &s->n_seq); // read a mini-batch
338,850 ( 0.54%)  => /home/kisliy/minimap2_v2.18/bseq.c:mm_bseq_read (2x)
      4 ( 0.00%)  		if (s->seq) {
      .           			uint32_t old_m, m;
      9 ( 0.00%)  			assert((uint64_t)p->mi->n_seq + s->n_seq <= UINT32_MAX); // to prevent integer overflow
      .           			// make room for p->mi->seq
      1 ( 0.00%)  			old_m = p->mi->n_seq, m = p->mi->n_seq + s->n_seq;
     33 ( 0.00%)  			kroundup32(m); kroundup32(old_m);
      2 ( 0.00%)  			if (old_m != m)
      8 ( 0.00%)  				p->mi->seq = (mm_idx_seq_t*)krealloc(p->mi->km, p->mi->seq, m * sizeof(mm_idx_seq_t));
    421 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:krealloc (1x)
      .           			// make room for p->mi->S
      2 ( 0.00%)  			if (!(p->mi->flag & MM_I_NO_SEQ)) {
      .           				uint64_t sum_len, old_max_len, max_len;
     14 ( 0.00%)  				for (i = 0, sum_len = 0; i < s->n_seq; ++i) sum_len += s->seq[i].l_seq;
      4 ( 0.00%)  				old_max_len = (p->sum_len + 7) / 8;
      2 ( 0.00%)  				max_len = (p->sum_len + sum_len + 7) / 8;
     40 ( 0.00%)  				kroundup64(old_max_len); kroundup64(max_len);
      2 ( 0.00%)  				if (old_max_len != max_len) {
      5 ( 0.00%)  					p->mi->S = (uint32_t*)realloc(p->mi->S, max_len * 4);
    211 ( 0.00%)  => ???:realloc (1x)
     14 ( 0.00%)  					memset(&p->mi->S[old_max_len], 0, 4 * (max_len - old_max_len));
  1,154 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
  1,808 ( 0.00%)  => ???:__GI_memset (1x)
      .           				}
      .           			}
      .           			// populate p->mi->seq
     12 ( 0.00%)  			for (i = 0; i < s->n_seq; ++i) {
      4 ( 0.00%)  				mm_idx_seq_t *seq = &p->mi->seq[p->mi->n_seq];
      .           				uint32_t j;
      3 ( 0.00%)  				if (!(p->mi->flag & MM_I_NO_NAME)) {
     11 ( 0.00%)  					seq->name = (char*)kmalloc(p->mi->km, strlen(s->seq[i].name) + 1);
  1,153 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
     34 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kmalloc (1x)
     14 ( 0.00%)  => ???:__strlen_sse2_pminub (1x)
     13 ( 0.00%)  					strcpy(seq->name, s->seq[i].name);
  1,159 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
     21 ( 0.00%)  => ???:__strcpy_sse2_unaligned (1x)
      .           				} else seq->name = 0;
      4 ( 0.00%)  				seq->len = s->seq[i].l_seq;
      2 ( 0.00%)  				seq->offset = p->sum_len;
      1 ( 0.00%)  				seq->is_alt = 0;
      .           				// copy the sequence
      2 ( 0.00%)  				if (!(p->mi->flag & MM_I_NO_SEQ)) {
 66,282 ( 0.11%)  					for (j = 0; j < seq->len; ++j) { // TODO: this is not the fastest way, but let's first see if speed matters here
 33,138 ( 0.05%)  						uint64_t o = p->sum_len + j;
 16,569 ( 0.03%)  						int c = seq_nt4_table[(uint8_t)s->seq[i].seq[j]];
115,983 ( 0.18%)  						mm_seq4_set(p->mi->S, o, c);
      .           					}
      .           				}
      .           				// update p->sum_len and p->mi->n_seq
      2 ( 0.00%)  				p->sum_len += seq->len;
      4 ( 0.00%)  				s->seq[i].rid = p->mi->n_seq++;
      .           			}
      .           			return s;
      3 ( 0.00%)  		} else free(s);
     88 ( 0.00%)  => ???:free (1x)
      6 ( 0.00%)      } else if (step == 1) { // step 1: compute sketch
      .                   step_t *s = (step_t*)in;
      9 ( 0.00%)  		for (i = 0; i < s->n_seq; ++i) {
      2 ( 0.00%)  			mm_bseq1_t *t = &s->seq[i];
      3 ( 0.00%)  			if (t->l_seq > 0)
     12 ( 0.00%)  				mm_sketch(0, t->seq, t->l_seq, p->mi->w, p->mi->k, t->rid, p->mi->flag&MM_I_HPC, &s->a);
2,220,997 ( 3.54%)  => /home/kisliy/minimap2_v2.18/sketch.c:mm_sketch (1x)
      .           			else if (mm_verbose >= 2)
      .           				fprintf(stderr, "[WARNING] the length database sequence '%s' is 0\n", t->name);
     10 ( 0.00%)  			free(t->seq); free(t->name);
  1,122 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
    204 ( 0.00%)  => ???:free (2x)
      .           		}
      4 ( 0.00%)  		free(s->seq); s->seq = 0;
    116 ( 0.00%)  => ???:free (1x)
      1 ( 0.00%)  		return s;
      2 ( 0.00%)      } else if (step == 2) { // dispatch sketch to buckets
      .                   step_t *s = (step_t*)in;
      7 ( 0.00%)  		mm_idx_add(p->mi, s->a.n, s->a.a);
780,025 ( 1.24%)  => index.c:mm_idx_add.isra.0 (1x)
      8 ( 0.00%)  		kfree(0, s->a.a); free(s);
     88 ( 0.00%)  => ???:free (1x)
    293 ( 0.00%)  => /home/kisliy/minimap2_v2.18/kalloc.c:kfree (1x)
      .           	}
      2 ( 0.00%)      return 0;
     33 ( 0.00%)  }
      .           
      .           mm_idx_t *mm_idx_gen(mm_bseq_file_t *fp, int w, int k, int b, int flag, int mini_batch_size, int n_threads, uint64_t batch_size)
     16 ( 0.00%)  {
      .           	pipeline_t pl;
     21 ( 0.00%)  	if (fp == 0 || mm_bseq_eof(fp)) return 0;
     18 ( 0.00%)  => /home/kisliy/minimap2_v2.18/bseq.c:mm_bseq_eof (2x)
      3 ( 0.00%)  	memset(&pl, 0, sizeof(pipeline_t));
      4 ( 0.00%)  	pl.mini_batch_size = (uint64_t)mini_batch_size < batch_size? mini_batch_size : batch_size;
      2 ( 0.00%)  	pl.batch_size = batch_size;
      1 ( 0.00%)  	pl.fp = fp;
      6 ( 0.00%)  	pl.mi = mm_idx_init(w, k, b, flag);
    830 ( 0.00%)  => index.c:mm_idx_init (1x)
      .           
      7 ( 0.00%)  	kt_pipeline(n_threads < 3? n_threads : 3, worker_pipeline, &pl, 3);
  9,399 ( 0.01%)  => /home/kisliy/minimap2_v2.18/kthread.c:kt_pipeline (1x)
      2 ( 0.00%)  	if (mm_verbose >= 3)
     21 ( 0.00%)  		fprintf(stderr, "[M::%s::%.3f*%.2f] collected minimizers\n", __func__, realtime() - mm_realtime0, cputime() / (realtime() - mm_realtime0));
  3,602 ( 0.01%)  => ???:fprintf (1x)
  1,220 ( 0.00%)  => /home/kisliy/minimap2_v2.18/misc.c:cputime (1x)
  1,159 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
     28 ( 0.00%)  => /home/kisliy/minimap2_v2.18/misc.c:realtime (2x)
      .           
      1 ( 0.00%)  	mm_idx_post(pl.mi, n_threads);
      2 ( 0.00%)  	if (mm_verbose >= 3)
     17 ( 0.00%)  		fprintf(stderr, "[M::%s::%.3f*%.2f] sorted minimizers\n", __func__, realtime() - mm_realtime0, cputime() / (realtime() - mm_realtime0));
  3,489 ( 0.01%)  => ???:fprintf (1x)
     20 ( 0.00%)  => /home/kisliy/minimap2_v2.18/misc.c:cputime (1x)
     28 ( 0.00%)  => /home/kisliy/minimap2_v2.18/misc.c:realtime (2x)
      .           
      1 ( 0.00%)  	return pl.mi;
     16 ( 0.00%)  }
      .           
      .           mm_idx_t *mm_idx_build(const char *fn, int w, int k, int flag, int n_threads) // a simpler interface; deprecated
      .           {
      .           	mm_bseq_file_t *fp;
      .           	mm_idx_t *mi;
      .           	fp = mm_bseq_open(fn);
      .           	if (fp == 0) return 0;
      .           	mi = mm_idx_gen(fp, w, k, 14, flag, 1<<18, n_threads, UINT64_MAX);
-- line 381 ----------------------------------------
-- line 529 ----------------------------------------
      .           	if (!(mi->flag & MM_I_NO_SEQ)) {
      .           		mi->S = (uint32_t*)malloc((sum_len + 7) / 8 * 4);
      .           		fread(mi->S, 4, (sum_len + 7) / 8, fp);
      .           	}
      .           	return mi;
      .           }
      .           
      .           int64_t mm_idx_is_idx(const char *fn)
      4 ( 0.00%)  {
      .           	int fd, is_idx = 0;
      .           	int64_t ret, off_end;
      .           	char magic[4];
      .           
      2 ( 0.00%)  	if (strcmp(fn, "-") == 0) return 0; // read from pipe; not an index
      9 ( 0.00%)  	fd = open(fn, O_RDONLY);
    984 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
      7 ( 0.00%)  => ???:open (1x)
      2 ( 0.00%)  	if (fd < 0) return -1; // error
      .           #ifdef WIN32
      .           	if ((off_end = _lseeki64(fd, 0, SEEK_END)) >= 4) {
      .           		_lseeki64(fd, 0, SEEK_SET);
      .           #else
     12 ( 0.00%)  	if ((off_end = lseek(fd, 0, SEEK_END)) >= 4) {
    999 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
      7 ( 0.00%)  => ???:lseek (1x)
      5 ( 0.00%)  		lseek(fd, 0, SEEK_SET);
      7 ( 0.00%)  => ???:lseek (1x)
      .           #endif // WIN32
      9 ( 0.00%)  		ret = read(fd, magic, 4);
    992 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
      7 ( 0.00%)  => ???:read (1x)
      7 ( 0.00%)  		if (ret == 4 && strncmp(magic, MM_IDX_MAGIC, 4) == 0)
      .           			is_idx = 1;
      .           	}
      7 ( 0.00%)  	close(fd);
    999 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
      7 ( 0.00%)  => ???:close (1x)
      1 ( 0.00%)  	return is_idx? off_end : 0;
      5 ( 0.00%)  }
      .           
      .           mm_idx_reader_t *mm_idx_reader_open(const char *fn, const mm_idxopt_t *opt, const char *fn_out)
      8 ( 0.00%)  {
      .           	int64_t is_idx;
      .           	mm_idx_reader_t *r;
      2 ( 0.00%)  	is_idx = mm_idx_is_idx(fn);
  4,072 ( 0.01%)  => index.c:mm_idx_is_idx (1x)
      2 ( 0.00%)  	if (is_idx < 0) return 0; // failed to open the index
      9 ( 0.00%)  	r = (mm_idx_reader_t*)calloc(1, sizeof(mm_idx_reader_t));
 58,244 ( 0.09%)  => ???:calloc (1x)
  1,153 ( 0.00%)  => ???:_dl_runtime_resolve (1x)
      2 ( 0.00%)  	r->is_idx = is_idx;
      8 ( 0.00%)  	if (opt) r->opt = *opt;
      .           	else mm_idxopt_init(&r->opt);
      2 ( 0.00%)  	if (r->is_idx) {
      .           		r->fp.idx = fopen(fn, "rb");
      .           		r->idx_size = is_idx;
      3 ( 0.00%)  	} else r->fp.seq = mm_bseq_open(fn);
  9,353 ( 0.01%)  => /home/kisliy/minimap2_v2.18/bseq.c:mm_bseq_open (1x)
      2 ( 0.00%)  	if (fn_out) r->fp_out = fopen(fn_out, "wb");
      .           	return r;
      7 ( 0.00%)  }
      .           
      .           void mm_idx_reader_close(mm_idx_reader_t *r)
      2 ( 0.00%)  {
      4 ( 0.00%)  	if (r->is_idx) fclose(r->fp.idx);
      2 ( 0.00%)  	else mm_bseq_close(r->fp.seq);
  1,402 ( 0.00%)  => /home/kisliy/minimap2_v2.18/bseq.c:mm_bseq_close (1x)
      3 ( 0.00%)  	if (r->fp_out) fclose(r->fp_out);
      3 ( 0.00%)  	free(r);
     89 ( 0.00%)  => ???:free (1x)
      1 ( 0.00%)  }
      .           
      .           mm_idx_t *mm_idx_reader_read(mm_idx_reader_t *r, int n_threads)
      8 ( 0.00%)  {
      .           	mm_idx_t *mi;
      6 ( 0.00%)  	if (r->is_idx) {
      .           		mi = mm_idx_load(r->fp.idx);
      .           		if (mi && mm_verbose >= 2 && (mi->k != r->opt.k || mi->w != r->opt.w || (mi->flag&MM_I_HPC) != (r->opt.flag&MM_I_HPC)))
      .           			fprintf(stderr, "[WARNING]\033[1;31m Indexing parameters (-k, -w or -H) overridden by parameters used in the prebuilt index.\033[0m\n");
      .           	} else
     24 ( 0.00%)  		mi = mm_idx_gen(r->fp.seq, r->opt.w, r->opt.k, r->opt.bucket_bits, r->opt.flag, r->opt.mini_batch_size, n_threads, r->opt.batch_size);
4,796,602 ( 7.65%)  => index.c:mm_idx_gen (2x)
      5 ( 0.00%)  	if (mi) {
      3 ( 0.00%)  		if (r->fp_out) mm_idx_dump(r->fp_out, mi);
      4 ( 0.00%)  		mi->index = r->n_parts++;
      .           	}
      .           	return mi;
     10 ( 0.00%)  }
      .           
      .           int mm_idx_reader_eof(const mm_idx_reader_t *r) // TODO: in extremely rare cases, mm_bseq_eof() might not work
      2 ( 0.00%)  {
      5 ( 0.00%)  	return r->is_idx? (feof(r->fp.idx) || ftell(r->fp.idx) == r->idx_size) : mm_bseq_eof(r->fp.seq);
     12 ( 0.00%)  => /home/kisliy/minimap2_v2.18/bseq.c:mm_bseq_eof (1x)
      1 ( 0.00%)  }
      .           
      .           #include <ctype.h>
      .           #include <zlib.h>
      .           #include "ksort.h"
      .           #include "kseq.h"
      .           KSTREAM_DECLARE(gzFile, gzread)
      .           
      .           int mm_idx_alt_read(mm_idx_t *mi, const char *fn)
-- line 613 ----------------------------------------
-- line 723 ----------------------------------------
      .           	mi->I = mm_idx_read_bed(mi, fn, read_junc);
      .           	if (mi->I == 0) return -1;
      .           	for (i = 0; i < mi->n_seq; ++i) // TODO: eliminate redundant intervals
      .           		radix_sort_bed(mi->I[i].a, mi->I[i].a + mi->I[i].n);
      .           	return 0;
      .           }
      .           
      .           int mm_idx_bed_junc(const mm_idx_t *mi, int32_t ctg, int32_t st, int32_t en, uint8_t *s)
    560 ( 0.00%)  {
      .           	int32_t i, left, right;
      .           	mm_idx_intv_t *r;
    392 ( 0.00%)  	memset(s, 0, en - st);
  2,701 ( 0.00%)  => ???:__GI_memset (56x)
    280 ( 0.00%)  	if (mi->I == 0 || ctg < 0 || ctg >= mi->n_seq) return -1;
      .           	r = &mi->I[ctg];
      .           	left = 0, right = r->n;
      .           	while (right > left) {
      .           		int32_t mid = left + ((right - left) >> 1);
      .           		if (r->a[mid].st >= st) right = mid;
      .           		else left = mid + 1;
      .           	}
      .           	for (i = left; i < r->n; ++i) {
-- line 743 ----------------------------------------
-- line 745 ----------------------------------------
      .           			if (r->a[i].strand > 0) {
      .           				s[r->a[i].st - st] |= 1, s[r->a[i].en - 1 - st] |= 2;
      .           			} else {
      .           				s[r->a[i].st - st] |= 8, s[r->a[i].en - 1 - st] |= 4;
      .           			}
      .           		}
      .           	}
      .           	return left;
    336 ( 0.00%)  }

--------------------------------------------------------------------------------
Ir                  
--------------------------------------------------------------------------------
56,330,538 (89.79%)  events annotated

